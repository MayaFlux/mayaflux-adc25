<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Ranjith Hegde" />
  <title>MayaFlux Technical Documentation</title>
  <style>

code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}

ul.task-list[class]{list-style: none;}
ul.task-list li input[type="checkbox"] {
font-size: inherit;
width: 0.8em;
margin: 0 0.8em 0.2em -1.6em;
vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}

html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
  <style type="text/css">:root {
--bg-primary: #1a1c24;
--bg-secondary: #23253a;
--bg-code: #2a2d3e;
--border-color: #2e3147;
--text-primary: #e2e4ea;
--text-secondary: #a3a7c7;
--accent-primary: #7a7ad9;
--accent-secondary: #b7c4ff;
--link-color: #8b8bdb;
}
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}
body {
font-family: "Georgia", "Cambria", "Times New Roman", serif;
font-size: 16px;
line-height: 1.7;
color: var(--text-primary);
background-color: var(--bg-primary);
padding: 20px;
max-width: 900px;
margin: 0 auto;
}

nav#TOC {
background: var(--bg-secondary);
border: 1px solid var(--border-color);
border-radius: 6px;
padding: 1.5em;
margin: 2em 0;
}
nav#TOC>ul {
list-style: none;
margin-left: 0;
}
nav#TOC ul ul {
list-style: none;
margin-left: 1.5em;
margin-top: 0.5em;
}
nav#TOC li {
margin-bottom: 0.6em;
}
nav#TOC>ul>li {
font-weight: 600;
margin-bottom: 1em;
}
nav#TOC>ul>li>ul>li {
font-weight: 400;
margin-bottom: 0.4em;
}
nav#TOC a {
color: var(--link-color);
}
nav#TOC a:hover {
color: var(--accent-secondary);
}

h1,
h2,
h3,
h4,
h5,
h6 {
font-family: "Fira Code", "JetBrains Mono", "Consolas", monospace;
font-weight: 600;
color: var(--accent-secondary);
margin-top: 2em;
margin-bottom: 0.8em;
line-height: 1.3;
}
h1 {
font-size: 2.5em;
margin-top: 0;
padding-bottom: 0.3em;
border-bottom: 3px solid var(--border-color);
color: var(--accent-primary);
}
h2 {
font-size: 1.8em;
padding-bottom: 0.2em;
border-bottom: 2px solid var(--border-color);
margin-top: 2.5em;
}
h3 {
font-size: 1.4em;
color: var(--text-primary);
}
h4 {
font-size: 1.2em;
color: var(--text-secondary);
}

p {
margin-bottom: 1.2em;
color: var(--text-primary);
}
strong {
color: var(--accent-secondary);
font-weight: 600;
}
em {
color: var(--text-secondary);
font-style: italic;
}

a {
color: var(--link-color);
text-decoration: none;
border-bottom: 1px solid transparent;
transition: border-color 0.2s;
}
a:hover {
border-bottom-color: var(--link-color);
}

code {
font-family: "Fira Code", "JetBrains Mono", "Consolas", monospace;
font-size: 0.9em;
background: var(--bg-code);
padding: 0.2em 0.4em;
border-radius: 3px;
color: #e8c4b8;
}
pre {
background: var(--bg-secondary);
border: 1px solid var(--border-color);
border-radius: 6px;
padding: 1.2em;
overflow-x: auto;
margin: 1.5em 0;
box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}
pre code {
background: transparent;
padding: 0;
font-size: 0.85em;
line-height: 1.5;
color: var(--text-primary);
}

ul,
ol {
margin-left: 1.8em;
margin-bottom: 1.2em;
}
li {
margin-bottom: 0.5em;
color: var(--text-primary);
}
ul ul,
ol ol,
ul ol,
ol ul {
margin-top: 0.5em;
margin-bottom: 0.5em;
}

blockquote {
border-left: 4px solid var(--accent-primary);
padding-left: 1.2em;
margin: 1.5em 0;
color: var(--text-secondary);
font-style: italic;
background: var(--bg-secondary);
padding: 1em 1em 1em 1.5em;
border-radius: 0 4px 4px 0;
}

table {
width: 100%;
border-collapse: collapse;
margin: 1.5em 0;
background: var(--bg-secondary);
border-radius: 6px;
overflow: hidden;
}
th,
td {
padding: 0.8em 1em;
text-align: left;
border-bottom: 1px solid var(--border-color);
}
th {
background: var(--bg-code);
color: var(--accent-secondary);
font-family: "Fira Code", monospace;
font-weight: 600;
}
tr:last-child td {
border-bottom: none;
}
tr:hover {
background: rgba(122, 122, 217, 0.05);
}

hr {
border: none;
border-top: 2px solid var(--border-color);
margin: 2.5em 0;
}

.header-info {
background: var(--bg-secondary);
border-left: 4px solid var(--accent-primary);
padding: 1.2em;
margin: 2em 0;
border-radius: 0 6px 6px 0;
}
.header-info p {
margin-bottom: 0.5em;
}
.header-info p:last-child {
margin-bottom: 0;
}

nav#TOC {
background: var(--bg-secondary);
border: 1px solid var(--border-color);
border-radius: 6px;
padding: 1.5em;
margin: 2em 0;
}
nav#TOC ul {
list-style: none;
margin-left: 0;
}
nav#TOC li {
margin-bottom: 0.4em;
}
nav#TOC>ul>li {
margin-bottom: 0.8em;
font-weight: 600;
}
nav#TOC a {
color: var(--link-color);
}

.emphasis-box {
background: rgba(122, 122, 217, 0.1);
border-left: 4px solid var(--accent-primary);
padding: 1.2em;
margin: 1.5em 0;
border-radius: 0 6px 6px 0;
}

@media print {
body {
background: white;
color: black;
max-width: 100%;
}
h1,
h2,
h3,
h4,
h5,
h6 {
color: black;
page-break-after: avoid;
}
pre,
blockquote,
table {
page-break-inside: avoid;
}
a {
color: black;
text-decoration: underline;
}
}

@media (max-width: 768px) {
body {
padding: 15px;
font-size: 15px;
}
h1 {
font-size: 2em;
}
h2 {
font-size: 1.5em;
}
pre {
padding: 1em;
font-size: 0.8em;
}
}

.sourceCode .kw {
color: #e78c8c;
font-weight: bold;
}

.sourceCode .dt {
color: #8bcdcd;
}

.sourceCode .dv {
color: #d4a76a;
}

.sourceCode .bn {
color: #d4a76a;
}

.sourceCode .fl {
color: #d4a76a;
}

.sourceCode .ch {
color: #b8bb87;
}

.sourceCode .st {
color: #b8bb87;
}

.sourceCode .co {
color: #7c7f93;
font-style: italic;
}

.sourceCode .ot {
color: #a3a7c7;
}

.sourceCode .fu {
color: #8b8bdb;
}

.sourceCode .er {
color: #e78c8c;
font-weight: bold;
}

.sourceCode .wa {
color: #e78c8c;
font-style: italic;
}

.sourceCode .cn {
color: #d4a76a;
}

.sourceCode .sc {
color: #b8bb87;
}

.sourceCode .vs {
color: #b8bb87;
}

.sourceCode .ss {
color: #b8bb87;
}

.sourceCode .va {
color: #a3a7c7;
}

.sourceCode .cf {
color: #e78c8c;
font-weight: bold;
}

.sourceCode .op {
color: #a3a7c7;
}

.sourceCode .pp {
color: #8bcdcd;
}

.sourceCode .at {
color: #8b8bdb;
}

.sourceCode .do {
color: #7c7f93;
font-style: italic;
}

.sourceCode .an {
color: #7c7f93;
font-style: italic;
}

.sourceCode .cv {
color: #7c7f93;
font-style: italic;
}

.sourceCode .in {
color: #7c7f93;
font-style: italic;
}
</style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">MayaFlux Technical Documentation</h1>
<p class="subtitle">ADC25 Virtual Poster Presentation - Technical Deep
Dive | Independent Developer | Early-Stage Architectural Research</p>
<p class="author">Ranjith Hegde</p>
<p class="date">November 2025</p>
</header>
<p><strong>Copyright © 2025 Ranjith Hegde / MayaFlux
Project</strong><br />
Licensed under GPL-3.0 | <a href="https://github.com/MayaFlux/mayaflux-adc25/blob/main/LICENSE">View
License</a></p>
<p><strong>Note:</strong> This document describes architectural patterns
developed over 8 months of research. Implementation details are
simplified for clarity. Full source code available at <a href="https://github.com/MayaFlux/MayaFlux">github.com/MayaFlux/MayaFlux</a>
(private during development).</p>
<hr />
<p>Explore the first MayaFlux tutorial here: <a href="tutorial.html">Sculpting Data Part I</a></p>
<hr />
<h2 id="abstract">Abstract</h2>
<p>MayaFlux demonstrates C++20-enabled unified multimedia processing
through complete architectural composability. The framework implements
lock-free atomic synchronization, coroutine-based temporal coordination,
grammar-driven computation, and N-dimensional data abstractions that
treat audio, graphics, and arbitrary data streams as unified numerical
transformations rather than separate domains constrained by analog
metaphors.</p>
<p>This document presents the architectural foundations, implementation
strategies, and paradigm shifts that enable truly digital-first creative
computation across both audio and visual processing domains.</p>
<hr />
<h2 id="table-of-contents">Table of Contents</h2>
<ol type="1">
<li><a href="#the-digital-first-paradigm">The Digital-First
Paradigm</a></li>
<li><a href="#core-architectural-foundations">Core Architectural
Foundations</a></li>
<li><a href="#lock-free-processing-architecture">Lock-Free Processing
Architecture</a></li>
<li><a href="#coroutine-temporal-coordination">Coroutine Temporal
Coordination</a></li>
<li><a href="#clock-systems-passive-and-active-temporal-drivers">Clock
Systems: Passive and Active Temporal Drivers</a></li>
<li><a href="#computationgrammar-declarative-operation-matching">ComputationGrammar:
Declarative Operation Matching</a></li>
<li><a href="#graphics-processing-architecture">Graphics Processing
Architecture</a></li>
<li><a href="#yantra-pipeline-declarative-transformation-composition">Yantra
Pipeline: Declarative Transformation Composition</a></li>
<li><a href="#nddata-unified-cross-modal-processing">NDData: Unified
Cross-Modal Processing</a></li>
<li><a href="#window-management-as-coroutines">Window Management as
Coroutines</a></li>
<li><a href="#domain-composition-and-processing-tokens">Domain
Composition and Processing Tokens</a></li>
<li><a href="#current-implementation-status">Current Implementation
Status</a></li>
<li><a href="#future-vision-and-research-questions">Future Vision and
Research Questions</a></li>
</ol>
<hr />
<h2 id="the-digital-first-paradigm">The Digital-First Paradigm</h2>
<h3 id="moving-beyond-analog-metaphors">Moving Beyond Analog
Metaphors</h3>
<p>Traditional multimedia software treats digital processing as a
simulation of analog hardware. This creates artificial constraints:</p>
<ul>
<li><strong>Separate processing domains</strong>: Audio, video, and
control are isolated systems</li>
<li><strong>Callback-based timing</strong>: Legacy models inherited from
hardware interrupts</li>
<li><strong>File-based workflows</strong>: Data as static resources
rather than live computational material</li>
<li><strong>Hardware simulation</strong>: Virtual knobs, cables, and
oscilloscopes instead of computational possibilities</li>
</ul>
<p>MayaFlux embraces <strong>true digital paradigms</strong>:</p>
<ul>
<li><strong>Unified data transformation</strong>: All streams are
numerical data that can interact</li>
<li><strong>Coroutine temporal control</strong>: Time as creative
material, not interrupt callbacks</li>
<li><strong>Grammar-defined operations</strong>: Declarative computation
based on data characteristics</li>
<li><strong>Ahead-of-time processing</strong>: Pre-calculate
transformations impossible in analog</li>
<li><strong>Recursive algorithms</strong>: Process data in ways hardware
cannot</li>
<li><strong>Cross-modal coordination</strong>: Audio parameters control
GPU compute shaders; visual analysis modulates filter parameters
seamlessly</li>
</ul>
<h3 id="core-philosophy-data-transformation-as-creative-medium">Core
Philosophy: Data Transformation as Creative Medium</h3>
<p>Rather than separating “programming” from “composing” or “designing,”
MayaFlux treats data transformation as the fundamental creative act.
Mathematical relationships become creative decisions. Temporal
coordination becomes compositional structure. Multi-dimensional data
access becomes creative material selection. GPU compute shaders process
audio spectra. Audio analysis drives visual shader parameters.</p>
<p>This isn’t just about efficiency—it’s about <strong>enabling creative
workflows that cannot exist in analog-inspired systems</strong>. When a
spectral analysis from audio processing directly feeds a compute shader
that modulates a visual buffer’s texture coordinates, with
sample-accurate synchronization via coroutines—that’s a creative pattern
analog metaphors cannot express.</p>
<hr />
<h2 id="core-architectural-foundations">Core Architectural
Foundations</h2>
<p>MayaFlux is built on five interconnected paradigms that apply equally
to audio and graphics:</p>
<h3 id="nodes-unit-by-unit-transformation-precision">1. Nodes:
Unit-by-Unit Transformation Precision</h3>
<p>Nodes provide single-sample or single-frame transformation where
mathematical relationships become creative decisions. Each node operates
at unit precision with lock-free atomic registration.</p>
<p><strong>Key characteristics:</strong></p>
<ul>
<li>Sample-accurate audio processing or frame-accurate visual
processing</li>
<li>Lock-free concurrent operation through atomic operations</li>
<li>Fluent chaining via operators (<code>&gt;&gt;</code>,
<code>*</code>, <code>+</code>)</li>
<li>Channel-based routing with bitmask management</li>
<li>Direct <code>process_sample()</code> or <code>process_frame()</code>
control</li>
</ul>
<h3 id="buffers-temporal-gathering-spaces">2. Buffers: Temporal
Gathering Spaces</h3>
<p>Buffers accumulate individual moments into collective expressions.
Unlike traditional buffers that “store” data, MayaFlux buffers are
transient collectors that gather → release → await. This applies to both
AudioBuffers and VKBuffers (GPU buffers).</p>
<p><strong>Key characteristics:</strong></p>
<ul>
<li>Processing chains with custom processor extensibility</li>
<li>Shared data coordination between buffers</li>
<li>Backend-agnostic (audio, graphics, custom)</li>
<li>Token-based processing domain assignment</li>
<li>Default processors with override capability</li>
</ul>
<h3 id="coroutines-time-as-compositional-material">3. Coroutines: Time
as Compositional Material</h3>
<p>C++20 coroutines transform time into creative material, enabling
complex temporal coordination impossible with traditional callbacks.
Sample-accurate audio coordination and frame-accurate graphics
coordination use the same underlying coroutine infrastructure.</p>
<p><strong>Key characteristics:</strong></p>
<ul>
<li>Sample-accurate and frame-accurate temporal domains</li>
<li>Vruta (scheduling infrastructure) + Kriya (creative patterns)</li>
<li>EventChains for sequential temporal composition</li>
<li>Buffer capture mechanisms for windowed analysis</li>
<li>Cross-domain synchronization (audio ↔︎ graphics)</li>
</ul>
<h3 id="containers-multi-dimensional-data-architecture">4. Containers:
Multi-Dimensional Data Architecture</h3>
<p>Containers organize data as compositional material through
region-based access with metadata organization. The same abstractions
work for audio samples, spectral data, pixel arrays, and arbitrary
tensors.</p>
<p><strong>Key characteristics:</strong></p>
<ul>
<li>NDData abstractions for unified dimensional access</li>
<li>Region-based selection (temporal spans, spatial areas, frequency
ranges)</li>
<li>RegionGroups with rich metadata for creative workflow</li>
<li>Cross-modal data types (audio, spectral, visual, tensors)</li>
<li>Grammar-compatible data transformation pipelines</li>
</ul>
<h3 id="compute-matrix-declarative-and-composable-computation-engine">5.
Compute Matrix: Declarative and Composable Computation Engine</h3>
<p>Compute Matrix allows sequencing or composing different
<code>ComputeOperations</code> that work on any data modality through
unified interfaces.</p>
<p><strong>Key characteristics:</strong></p>
<ul>
<li>Operations are of type: <code>Analyzers</code>,
<code>Extractors</code>, <code>Sorters</code>, and
<code>Transformers</code></li>
<li>Each operation has a Universal abstract class and concrete
implementations</li>
<li>Design allows creating new operations on the fly or offloading to
dedicated compute units</li>
<li>Works with NDData using concepts for compile-time safety</li>
<li>Backend-agnostic (CPU, GPU, custom accelerators)</li>
</ul>
<hr />
<h2 id="lock-free-processing-architecture">Lock-Free Processing
Architecture</h2>
<h3 id="the-challenge">The Challenge</h3>
<p>Real-time multimedia processing requires:</p>
<ul>
<li>Concurrent node/buffer/coroutine registration without blocking</li>
<li>Sample-accurate and frame-accurate timing without lock
contention</li>
<li>Dynamic graph modifications during processing</li>
<li>Zero-allocation in critical paths</li>
</ul>
<h3 id="the-solution-atomic-state-guards">The Solution: Atomic State
Guards</h3>
<p>MayaFlux implements <strong>wait-free registration</strong> and
<strong>atomic accumulation</strong> patterns across both audio and
graphics domains:</p>
<h4 id="rootnode-lock-free-coordination">RootNode Lock-Free
Coordination</h4>
<p>Each processing domain (per channel, per token) has a
<code>RootNode</code> that acts as the central coordinator:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RootNode provides lock-free node registration</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> RootNode <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>atomic<span class="op">&lt;</span>ProcessingState<span class="op">&gt;</span> <span class="va">m_processing_state</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Node<span class="op">&gt;&gt;</span> <span class="va">m_nodes</span><span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> register_node<span class="op">(</span>shared_ptr<span class="op">&lt;</span>Node<span class="op">&gt;</span> node<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="va">m_is_processing</span><span class="op">.</span>load<span class="op">(</span><span class="bu">std::</span>memory_order_acquire<span class="op">))</span> <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span><span class="va">m_Nodes</span><span class="op">.</span>end<span class="op">()</span> <span class="op">!=</span> <span class="bu">std::</span>ranges::find<span class="op">(</span><span class="va">m_Nodes</span><span class="op">,</span> node<span class="op">))</span> <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>                <span class="dt">uint32_t</span> state <span class="op">=</span> node<span class="op">-&gt;</span><span class="va">m_state</span><span class="op">.</span>load<span class="op">();</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>state <span class="op">&amp;</span> Utils<span class="op">::</span>NodeState<span class="op">::</span>INACTIVE<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>                    atomic_remove_flag<span class="op">(</span>node<span class="op">-&gt;</span><span class="va">m_state</span><span class="op">,</span> Utils<span class="op">::</span>NodeState<span class="op">::</span>INACTIVE<span class="op">);</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>                    atomic_add_flag<span class="op">(</span>node<span class="op">-&gt;</span><span class="va">m_state</span><span class="op">,</span> Utils<span class="op">::</span>NodeState<span class="op">::</span>ACTIVE<span class="op">);</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span><span class="op">;</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span><span class="op">&amp;</span> <span class="va">m_pending_op</span> <span class="op">:</span> <span class="va">m_pending_ops</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>                <span class="dt">bool</span> expected <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span><span class="va">m_pending_op</span><span class="op">.</span>active<span class="op">.</span>compare_exchange_strong<span class="op">(</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>                        expected<span class="op">,</span> <span class="kw">true</span><span class="op">,</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">std::</span>memory_order_acquire<span class="op">,</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">std::</span>memory_order_relaxed<span class="op">))</span> <span class="op">{</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>                    <span class="va">m_pending_op</span><span class="op">.</span>node <span class="op">=</span> node<span class="op">;</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>                    atomic_remove_flag<span class="op">(</span>node<span class="op">-&gt;</span><span class="va">m_state</span><span class="op">,</span> Utils<span class="op">::</span>NodeState<span class="op">::</span>ACTIVE<span class="op">);</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>                    atomic_add_flag<span class="op">(</span>node<span class="op">-&gt;</span><span class="va">m_state</span><span class="op">,</span> Utils<span class="op">::</span>NodeState<span class="op">::</span>INACTIVE<span class="op">);</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>                    <span class="va">m_pending_count</span><span class="op">.</span>fetch_add<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="bu">std::</span>memory_order_relaxed<span class="op">);</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> <span class="op">(</span><span class="va">m_is_processing</span><span class="op">.</span>load<span class="op">(</span><span class="bu">std::</span>memory_order_acquire<span class="op">))</span> <span class="op">{</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>                <span class="va">m_is_processing</span><span class="op">.</span>wait<span class="op">(</span><span class="kw">true</span><span class="op">,</span> <span class="bu">std::</span>memory_order_acquire<span class="op">);</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_Nodes</span><span class="op">.</span>push_back<span class="op">(</span>node<span class="op">);</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uint32_t</span> state <span class="op">=</span> node<span class="op">-&gt;</span><span class="va">m_state</span><span class="op">.</span>load<span class="op">();</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>        atomic_add_flag<span class="op">(</span>node<span class="op">-&gt;</span><span class="va">m_state</span><span class="op">,</span> Utils<span class="op">::</span>NodeState<span class="op">::</span>ACTIVE<span class="op">);</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> process_sample<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>preprocess<span class="op">())</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="fl">0.</span><span class="op">;</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> sample <span class="op">=</span> <span class="fl">0.</span><span class="op">;</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span><span class="op">&amp;</span> node <span class="op">:</span> <span class="va">m_Nodes</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>            <span class="dt">uint32_t</span> state <span class="op">=</span> node<span class="op">-&gt;</span><span class="va">m_state</span><span class="op">.</span>load<span class="op">();</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(!(</span>state <span class="op">&amp;</span> Utils<span class="op">::</span>NodeState<span class="op">::</span>PROCESSED<span class="op">))</span> <span class="op">{</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>                <span class="kw">auto</span> generator <span class="op">=</span> <span class="bu">std::</span>dynamic_pointer_cast<span class="op">&lt;</span>Nodes<span class="op">::</span>Generator<span class="op">::</span>Generator<span class="op">&gt;(</span>node<span class="op">);</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>generator <span class="op">&amp;&amp;</span> generator<span class="op">-&gt;</span>should_mock_process<span class="op">())</span> <span class="op">{</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>                    generator<span class="op">-&gt;</span>process_sample<span class="op">(</span><span class="fl">0.</span><span class="op">);</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>                    sample <span class="op">+=</span> node<span class="op">-&gt;</span>process_sample<span class="op">(</span><span class="fl">0.</span><span class="op">);</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>                atomic_add_flag<span class="op">(</span>node<span class="op">-&gt;</span><span class="va">m_state</span><span class="op">,</span> Utils<span class="op">::</span>NodeState<span class="op">::</span>PROCESSED<span class="op">);</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>                sample <span class="op">+=</span> node<span class="op">-&gt;</span>get_last_output<span class="op">();</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>        postprocess<span class="op">();</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> sample<span class="op">;</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><strong>Key insights:</strong></p>
<ul>
<li>No locks in audio callback path</li>
<li>Registration deferred to safe states</li>
<li>Atomic accumulation without contention</li>
<li>Channel-based processing with bitmask checks</li>
</ul>
<h4 id="nodegraphmanager-coordination">NodeGraphManager
Coordination</h4>
<p>The <code>NodeGraphManager</code> coordinates multiple RootNodes
across channels and tokens:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Each token/channel combination has its own RootNode</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>unordered_map<span class="op">&lt;</span>ProcessingToken<span class="op">,</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>RootNode<span class="op">&gt;&gt;&gt;</span> <span class="va">m_root_nodes</span><span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Concurrent registration across domains</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> register_node_to_channel<span class="op">(</span>shared_ptr<span class="op">&lt;</span>Node<span class="op">&gt;</span> node<span class="op">,</span> <span class="dt">uint32_t</span> channel<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> token <span class="op">=</span> node<span class="op">-&gt;</span>get_processing_token<span class="op">();</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span><span class="op">&amp;</span> root <span class="op">=</span> <span class="va">m_root_nodes</span><span class="op">[</span>token<span class="op">][</span>channel<span class="op">];</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Atomic registration - defers if currently processing</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(!</span>root<span class="op">-&gt;</span>register_node<span class="op">(</span>node<span class="op">))</span> <span class="op">{</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>this_thread::yield<span class="op">();</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Update channel bitmask atomically</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint32_t</span> mask <span class="op">=</span> node<span class="op">-&gt;</span><span class="va">m_channel_mask</span><span class="op">.</span>load<span class="op">();</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    node<span class="op">-&gt;</span><span class="va">m_channel_mask</span><span class="op">.</span>store<span class="op">(</span>mask <span class="op">|</span> <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> channel<span class="op">));</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This pattern extends to <strong>buffers</strong> (BufferManager with
RootAudioBuffer and RootGraphicsBuffer) and <strong>coroutines</strong>
(TaskScheduler), providing consistent lock-free coordination across all
processing systems—audio and graphics alike.</p>
<hr />
<h2 id="coroutine-temporal-coordination">Coroutine Temporal
Coordination</h2>
<h3 id="vruta-scheduling-infrastructure">Vruta: Scheduling
Infrastructure</h3>
<p>Vruta provides the foundational scheduling system for coroutine
coordination:</p>
<h4 id="taskscheduler-architecture">TaskScheduler Architecture</h4>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TaskScheduler <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Clock systems for different temporal domains</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unordered_map<span class="op">&lt;</span>ProcessingToken<span class="op">,</span> <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>Clock<span class="op">&gt;&gt;</span> <span class="va">m_clocks</span><span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Task hierarchies per domain</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unordered_map<span class="op">&lt;</span>ProcessingToken<span class="op">,</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>shared_ptr<span class="op">&lt;</span>Routine<span class="op">&gt;&gt;&gt;</span> <span class="va">m_tasks</span><span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> add_task<span class="op">(</span>shared_ptr<span class="op">&lt;</span>Routine<span class="op">&gt;</span> routine<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Extract token from awaiter type</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> token <span class="op">=</span> routine<span class="op">-&gt;</span>get_processing_token<span class="op">();</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Register with appropriate clock</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_tasks</span><span class="op">[</span>token<span class="op">].</span>push_back<span class="op">(</span>routine<span class="op">);</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_clocks</span><span class="op">[</span>token<span class="op">]-&gt;</span>register_listener<span class="op">(</span>routine<span class="op">);</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> process_token<span class="op">(</span>ProcessingToken token<span class="op">,</span> <span class="dt">uint64_t</span> units<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Advance clock</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_clocks</span><span class="op">[</span>token<span class="op">]-&gt;</span>tick<span class="op">(</span>units<span class="op">);</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Process suspended coroutines</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span><span class="op">&amp;</span> task <span class="op">:</span> <span class="va">m_tasks</span><span class="op">[</span>token<span class="op">])</span> <span class="op">{</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>task<span class="op">-&gt;</span>should_resume<span class="op">())</span> <span class="op">{</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>                task<span class="op">-&gt;</span>resume<span class="op">();</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h4 id="sample-accurate-coordination">Sample-Accurate Coordination</h4>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Sample-accurate metro pattern</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> metro_routine <span class="op">=</span> Kriya<span class="op">::</span>metro<span class="op">(*</span>scheduler<span class="op">,</span> <span class="fl">0.25</span><span class="op">,</span> <span class="op">[]()</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    trigger_event<span class="op">();</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="op">});</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Internally uses SampleDelay awaiter:</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> SampleDelay <span class="op">{</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> samples_remaining<span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> await_ready<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> samples_remaining <span class="op">==</span> <span class="dv">0</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> await_suspend<span class="op">(</span>coroutine_handle<span class="op">&lt;&gt;</span> handle<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Register with SampleClock</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        scheduler<span class="op">-&gt;</span>register_delay<span class="op">(</span><span class="kw">this</span><span class="op">,</span> samples_remaining<span class="op">);</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="kriya-creative-temporal-patterns">Kriya: Creative Temporal
Patterns</h3>
<p>Kriya builds expressive temporal constructs on Vruta’s
foundation:</p>
<h4 id="eventchains-for-sequential-composition">EventChains for
Sequential Composition</h4>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> event_chain <span class="op">=</span> MayaFlux<span class="op">::</span>create_event_chain<span class="op">()</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>then<span class="op">([]()</span> <span class="op">{</span> start_process<span class="op">();</span> <span class="op">},</span> <span class="fl">0.0</span><span class="op">)</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>then<span class="op">([]()</span> <span class="op">{</span> modulate_filter<span class="op">();</span> <span class="op">},</span> <span class="fl">0.125</span><span class="op">)</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>then<span class="op">([]()</span> <span class="op">{</span> trigger_release<span class="op">();</span> <span class="op">},</span> <span class="fl">0.5</span><span class="op">);</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>event_chain<span class="op">.</span>start<span class="op">();</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Internally creates coroutine with timed suspension:</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>Routine execute_chain<span class="op">()</span> <span class="op">{</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">co_await</span> SampleDelay<span class="op">{</span> Utils<span class="op">::</span>seconds_to_samples<span class="op">(</span><span class="fl">0.125</span><span class="op">)</span> <span class="op">};</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    start_process<span class="op">();</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">co_await</span> BufferDelay<span class="op">{</span> <span class="dv">4</span> <span class="op">};</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    modulate_filter<span class="op">();</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">co_await</span> FrameDelay<span class="op">{</span> <span class="dv">60</span> <span class="op">};</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    trigger_release<span class="op">();</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="buffer-capture-mechanisms">Buffer Capture Mechanisms</h4>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> batch_accumulation_pipeline<span class="op">()</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> scheduler <span class="op">=</span> MayaFlux<span class="op">::</span>get_scheduler<span class="op">();</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> buffer_manager <span class="op">=</span> scheduler<span class="op">-&gt;</span>get_buffer_manager<span class="op">();</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> pipeline <span class="op">=</span> Kriya<span class="op">::</span>BufferPipeline<span class="op">::</span>create<span class="op">(*</span>scheduler<span class="op">,</span> buffer_manager<span class="op">)</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">-&gt;</span>with_strategy<span class="op">(</span>Kriya<span class="op">::</span>ExecutionStrategy<span class="op">::</span>PHASED<span class="op">);</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>pipeline</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">&gt;&gt;</span> Kriya<span class="op">::</span>BufferOperation<span class="op">::</span>capture_from<span class="op">(</span>audio_buffer<span class="op">)</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>for_cycles<span class="op">(</span><span class="dv">20</span><span class="op">)</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">&gt;&gt;</span> Kriya<span class="op">::</span>BufferOperation<span class="op">::</span>transform<span class="op">([](</span>Kakshya<span class="op">::</span>DataVariant<span class="op">&amp;</span> data<span class="op">,</span> <span class="dt">uint32_t</span> cycle<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>            <span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> accumulated <span class="op">=</span> <span class="bu">std::</span>get<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;(</span>data<span class="op">);</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> process_batch<span class="op">(</span>accumulated<span class="op">);</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">})</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">&gt;&gt;</span> Kriya<span class="op">::</span>BufferOperation<span class="op">::</span>route_to_container<span class="op">(</span>output_stream<span class="op">);</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    pipeline<span class="op">-&gt;</span>execute_buffer_rate<span class="op">(</span><span class="dv">10</span><span class="op">);</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> streaming_buffer_modification<span class="op">()</span> <span class="op">{</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> scheduler <span class="op">=</span> MayaFlux<span class="op">::</span>get_scheduler<span class="op">();</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> buffer_manager <span class="op">=</span> scheduler<span class="op">-&gt;</span>get_buffer_manager<span class="op">();</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> pipeline <span class="op">=</span> Kriya<span class="op">::</span>BufferPipeline<span class="op">::</span>create<span class="op">(*</span>scheduler<span class="op">,</span> buffer_manager<span class="op">)</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">-&gt;</span>with_strategy<span class="op">(</span>Kriya<span class="op">::</span>ExecutionStrategy<span class="op">::</span>STREAMING<span class="op">);</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>pipeline</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">&gt;&gt;</span> Kriya<span class="op">::</span>BufferOperation<span class="op">::</span>capture_from<span class="op">(</span>audio_buffer<span class="op">)</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>for_cycles<span class="op">(</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">&gt;&gt;</span> Kriya<span class="op">::</span>BufferOperation<span class="op">::</span>modify_buffer<span class="op">(</span>audio_buffer<span class="op">,</span> <span class="op">[](</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Buffers<span class="op">::</span>AudioBuffer<span class="op">&gt;</span> buf<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span><span class="op">&amp;</span> samples <span class="op">=</span> buf<span class="op">-&gt;</span>get_data<span class="op">();</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span><span class="op">&amp;</span> s <span class="op">:</span> samples<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>                s <span class="op">*=</span> <span class="fl">0.9</span><span class="op">;</span>  <span class="co">// Simple gain reduction</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>        <span class="op">}).</span>as_streaming<span class="op">();</span></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>    pipeline<span class="op">-&gt;</span>execute_buffer_rate<span class="op">();</span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="timer-operations">Timer Operations</h4>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">// One-shot timer</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>Timer timer<span class="op">(*</span>scheduler<span class="op">);</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>timer<span class="op">.</span>schedule<span class="op">(</span><span class="fl">2.0</span><span class="op">,</span> <span class="op">[]()</span> <span class="op">{</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Two seconds elapsed&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="op">});</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Node temporal control</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>NodeTimer node_timer<span class="op">(*</span>scheduler<span class="op">,</span> <span class="op">*</span>graph_manager<span class="op">);</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>node_timer<span class="op">.</span>play_for<span class="op">(</span>sine_node<span class="op">,</span> <span class="fl">2.0</span><span class="op">);</span>  <span class="co">// Play for 2 seconds</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="co">// Timed action with start/stop</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>TimedAction action<span class="op">(*</span>scheduler<span class="op">);</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>action<span class="op">.</span>execute<span class="op">(</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">[]()</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Starting&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span> <span class="op">},</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">[]()</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Ending&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span> <span class="op">},</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="fl">3.0</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span></code></pre></div>
<hr />
<h2 id="clock-systems-passive-and-active-temporal-drivers">Clock
Systems: Passive and Active Temporal Drivers</h2>
<p>MayaFlux implements two fundamental clock types with different
coordination philosophies:</p>
<h3 id="sampleclock-passive-temporal-tracking">SampleClock: Passive
Temporal Tracking</h3>
<p>The <code>SampleClock</code> is <strong>passive</strong>—it doesn’t
drive processing, but is updated by the audio backend and notifies
listeners:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SampleClock <span class="op">:</span> <span class="kw">public</span> Clock <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>atomic<span class="op">&lt;</span><span class="dt">uint64_t</span><span class="op">&gt;</span> <span class="va">m_current_sample</span><span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> <span class="va">m_sample_rate</span><span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Called by audio backend during callback</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> tick<span class="op">(</span><span class="dt">uint64_t</span> samples<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_current_sample</span><span class="op">.</span>fetch_add<span class="op">(</span>samples<span class="op">,</span> <span class="bu">std::</span>memory_order_release<span class="op">);</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        notify_listeners<span class="op">(</span>samples<span class="op">);</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> current_position<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">m_current_sample</span><span class="op">.</span>load<span class="op">(</span><span class="bu">std::</span>memory_order_acquire<span class="op">);</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> current_time<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(</span><span class="va">m_current_sample</span><span class="op">)</span> <span class="op">/</span> <span class="va">m_sample_rate</span><span class="op">;</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><strong>Key characteristics:</strong></p>
<ul>
<li>Updated by RtAudio backend after each callback</li>
<li>Provides sample-accurate timing for coroutines</li>
<li>Atomic position tracking for lock-free access</li>
<li>Notifies registered coroutines via TaskScheduler</li>
</ul>
<p><strong>Usage pattern:</strong></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Audio backend updates SampleClock</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> audio_callback<span class="op">(</span><span class="dt">float</span><span class="op">*</span> buffer<span class="op">,</span> <span class="dt">uint32_t</span> frames<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Process nodes/buffers</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    process_audio_graph<span class="op">(</span>buffer<span class="op">,</span> frames<span class="op">);</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Update temporal state</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    sample_clock<span class="op">-&gt;</span>tick<span class="op">(</span>frames<span class="op">);</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coroutines suspended on SampleDelay are notified</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="frameclock-active-temporal-driver">FrameClock: Active Temporal
Driver</h3>
<p>The <code>FrameClock</code> is <strong>active</strong>—it drives the
GPU/Vulkan processing thread at target FPS:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> FrameClock <span class="op">:</span> <span class="kw">public</span> Clock <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>atomic<span class="op">&lt;</span><span class="dt">uint64_t</span><span class="op">&gt;</span> <span class="va">m_current_frame</span><span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint32_t</span> <span class="va">m_target_fps</span><span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>chrono::steady_clock::time_point <span class="va">m_next_frame_time</span><span class="op">;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>chrono::nanoseconds <span class="va">m_frame_duration</span><span class="op">;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Drives graphics rendering loop</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> tick<span class="op">(</span><span class="dt">uint64_t</span> forced_frames <span class="op">=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> now <span class="op">=</span> <span class="bu">std::</span>chrono::steady_clock::now<span class="op">();</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uint64_t</span> frames_to_advance <span class="op">=</span> forced_frames <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">?</span> forced_frames <span class="op">:</span> calculate_elapsed_frames<span class="op">(</span>now<span class="op">);</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>frames_to_advance <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>            <span class="va">m_current_frame</span><span class="op">.</span>fetch_add<span class="op">(</span>frames_to_advance<span class="op">,</span> <span class="bu">std::</span>memory_order_release<span class="op">);</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>            update_fps_measurement<span class="op">(</span>now<span class="op">);</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>            <span class="va">m_last_tick_time</span> <span class="op">=</span> now<span class="op">;</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>            <span class="va">m_next_frame_time</span> <span class="op">=</span> now <span class="op">+</span> <span class="va">m_frame_duration</span><span class="op">;</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>            notify_listeners<span class="op">(</span>frames_to_advance<span class="op">);</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>chrono::nanoseconds time_until_next_frame<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> now <span class="op">=</span> <span class="bu">std::</span>chrono::steady_clock::now<span class="op">();</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> until_next <span class="op">=</span> <span class="va">m_next_frame_time</span> <span class="op">-</span> now<span class="op">;</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>until_next<span class="op">.</span>count<span class="op">()</span> <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">std::</span>chrono::nanoseconds<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>chrono::duration_cast<span class="op">&lt;</span><span class="bu">std::</span>chrono::nanoseconds<span class="op">&gt;(</span>until_next<span class="op">);</span></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> is_frame_late<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>chrono::steady_clock::now<span class="op">()</span> <span class="op">&gt;</span> <span class="va">m_next_frame_time</span><span class="op">;</span></span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><strong>Key characteristics:</strong></p>
<ul>
<li>Actively drives rendering loop at target FPS</li>
<li>Calculates frame timing and lag</li>
<li>Provides sleep hints for vsync coordination</li>
<li>Notifies visual-rate coroutines</li>
</ul>
<p><strong>Usage pattern:</strong></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Graphics thread driven by FrameClock</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> graphics_loop<span class="op">()</span> <span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>running<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        frame_clock<span class="op">-&gt;</span>tick<span class="op">();</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Process visual buffers</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        process_graphics_buffers<span class="op">();</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Render frame</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        render_to_swapchain<span class="op">();</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Sleep until next frame</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> sleep_duration <span class="op">=</span> frame_clock<span class="op">-&gt;</span>time_until_next_frame<span class="op">();</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>this_thread::sleep_for<span class="op">(</span>sleep_duration<span class="op">);</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="clock-coordination-philosophy">Clock Coordination
Philosophy</h3>
<p>This <strong>dual-clock architecture</strong> reflects a fundamental
design insight:</p>
<ul>
<li><strong>Audio processing is reactive</strong>: Driven by hardware
callback timing</li>
<li><strong>Visual processing is proactive</strong>: Self-timed to match
display refresh</li>
</ul>
<p>By implementing clocks with different ownership models, MayaFlux
enables natural coordination between these temporal domains while
maintaining their distinct characteristics.</p>
<p>Coroutines registered to SAMPLE_ACCURATE tokens listen to SampleClock
updates, while FRAME_ACCURATE coroutines listen to FrameClock. This
allows audio-visual synchronization through coordinated temporal
notification without forcing one domain to match the other’s timing
model.</p>
<hr />
<h2 id="computationgrammar-declarative-operation-matching">ComputationGrammar:
Declarative Operation Matching</h2>
<h3 id="the-problem">The Problem</h3>
<p>Traditional DSP frameworks require explicit operation selection:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Traditional approach - manual operation selection</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>is_audio_data<span class="op">(</span>input<span class="op">))</span> <span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    apply_fft<span class="op">(</span>input<span class="op">);</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>is_spectral_data<span class="op">(</span>input<span class="op">))</span> <span class="op">{</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    apply_ifft<span class="op">(</span>input<span class="op">);</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This becomes unwieldy for complex pipelines with multiple data
modalities, contexts, and transformation requirements.</p>
<h3 id="the-solution-rule-based-computation">The Solution: Rule-Based
Computation</h3>
<p>ComputationGrammar enables <strong>declarative operation
matching</strong> based on input characteristics:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ComputationGrammar <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Rule <span class="op">{</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string name<span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>        UniversalMatcher matcher<span class="op">;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        ExecutionFunction executor<span class="op">;</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>        ComputationContext context<span class="op">;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> priority<span class="op">;</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span>Rule<span class="op">&gt;</span> <span class="va">m_rules</span><span class="op">;</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Define rule declaratively</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    RuleBuilder create_rule<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> name<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> RuleBuilder<span class="op">(*</span><span class="kw">this</span><span class="op">,</span> name<span class="op">);</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Execute matching rule</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>any execute<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>any<span class="op">&amp;</span> input<span class="op">,</span> <span class="at">const</span> ExecutionContext<span class="op">&amp;</span> ctx<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span><span class="op">&amp;</span> rule <span class="op">:</span> <span class="va">m_rules</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>rule<span class="op">.</span>matcher<span class="op">.</span>matches<span class="op">(</span>input<span class="op">,</span> ctx<span class="op">)</span> <span class="op">&amp;&amp;</span> rule<span class="op">.</span>context <span class="op">==</span> ctx<span class="op">.</span>context<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> rule<span class="op">.</span>executor<span class="op">(</span>input<span class="op">,</span> ctx<span class="op">);</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">(</span><span class="st">&quot;No matching rule found&quot;</span><span class="op">);</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="rule-definition-examples">Rule Definition Examples</h3>
<h4 id="simple-type-based-matching">Simple Type-Based Matching</h4>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>grammar<span class="op">.</span>create_rule<span class="op">(</span><span class="st">&quot;normalize_audio&quot;</span><span class="op">)</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>with_context<span class="op">(</span>ComputationContext<span class="op">::</span>MATHEMATICAL<span class="op">)</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>with_priority<span class="op">(</span><span class="dv">100</span><span class="op">)</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="dt">matches_type</span><span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;()</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>executes<span class="op">([](</span><span class="at">const</span> <span class="bu">std::</span>any<span class="op">&amp;</span> input<span class="op">,</span> <span class="at">const</span> ExecutionContext<span class="op">&amp;</span> ctx<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> data <span class="op">=</span> safe_any_cast<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;(</span>input<span class="op">);</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> max_val <span class="op">=</span> <span class="op">*</span><span class="bu">std::</span>max_element<span class="op">(</span>data<span class="op">.</span>begin<span class="op">(),</span> data<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span><span class="op">&amp;</span> sample <span class="op">:</span> data<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>            sample <span class="op">/=</span> max_val<span class="op">;</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> data<span class="op">;</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">})</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>build<span class="op">();</span></span></code></pre></div>
<h4 id="complex-matcher-combinations">Complex Matcher Combinations</h4>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> spectral_matcher <span class="op">=</span> UniversalMatcher<span class="op">::</span>combine_and<span class="op">({</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    UniversalMatcher<span class="op">::</span>create_type_matcher<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span>DataVariant<span class="op">&gt;&gt;(),</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    UniversalMatcher<span class="op">::</span>create_context_matcher<span class="op">(</span>ComputationContext<span class="op">::</span>SPECTRAL<span class="op">),</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    UniversalMatcher<span class="op">::</span>create_parameter_matcher<span class="op">(</span><span class="st">&quot;frequency_range&quot;</span><span class="op">,</span> <span class="st">&quot;audio&quot;</span><span class="op">)</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="op">});</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>grammar<span class="op">.</span>create_rule<span class="op">(</span><span class="st">&quot;spectral_filter&quot;</span><span class="op">)</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>matches_custom<span class="op">(</span>spectral_matcher<span class="op">)</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>executes<span class="op">([](</span><span class="at">const</span> <span class="bu">std::</span>any<span class="op">&amp;</span> input<span class="op">,</span> <span class="at">const</span> ExecutionContext<span class="op">&amp;</span> ctx<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Apply frequency-domain filtering</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> data <span class="op">=</span> <span class="bu">std::</span>any_cast<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span>DataVariant<span class="op">&gt;&gt;(</span>input<span class="op">);</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> apply_spectral_filter<span class="op">(</span>data<span class="op">,</span> ctx<span class="op">);</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">})</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>build<span class="op">();</span></span></code></pre></div>
<h3 id="adaptive-pipeline-construction">Adaptive Pipeline
Construction</h3>
<p>ComputationGrammar enables <strong>context-aware operation
chains</strong>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> pipeline <span class="op">=</span> ComputationPipeline<span class="op">(</span>grammar<span class="op">);</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Pipeline automatically selects operations based on input</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result <span class="op">=</span> pipeline</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>add_input<span class="op">(</span>audio_data<span class="op">)</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>with_context<span class="op">(</span>ComputationContext<span class="op">::</span>TEMPORAL<span class="op">)</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>with_parameter<span class="op">(</span><span class="st">&quot;window_size&quot;</span><span class="op">,</span> <span class="dv">1024</span><span class="op">)</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>execute<span class="op">();</span></span></code></pre></div>
<p>The grammar system matches rules in priority order, enabling
hierarchical decision-making and exception handling patterns. This
declarative approach is central to MayaFlux’s expressive
power—transformations are specified by intent and characteristics rather
than explicit procedural logic.</p>
<hr />
<h2 id="graphics-processing-architecture">Graphics Processing
Architecture</h2>
<h3 id="the-challenge-unified-audio-visual-processing">The Challenge:
Unified Audio-Visual Processing</h3>
<p>Real-time graphics and audio processing have historically been
separate domains with incompatible architectures:</p>
<ul>
<li><strong>Different timing models</strong>: Audio uses hardware
callbacks; graphics uses render loops</li>
<li><strong>Different memory spaces</strong>: CPU (audio) vs GPU
(graphics) with expensive transfers</li>
<li><strong>Different abstractions</strong>: Samples/buffers vs
vertices/textures</li>
<li><strong>Isolated tooling</strong>: DAWs and visual tools don’t share
computational infrastructure</li>
</ul>
<p>MayaFlux solves this through <strong>unified buffer
abstractions</strong>, <strong>domain tokens</strong>, and
<strong>Portal coordination layers</strong> that provide seamless CPU ↔︎
GPU data flow while maintaining the performance characteristics of each
domain.</p>
<h3 id="vulkan-backend-foundation">Vulkan Backend Foundation</h3>
<p>The Vulkan backend provides low-level GPU resource management:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> VulkanBackend <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    vk<span class="op">::</span>Instance <span class="va">m_instance</span><span class="op">;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    vk<span class="op">::</span>PhysicalDevice <span class="va">m_physical_device</span><span class="op">;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    vk<span class="op">::</span>Device <span class="va">m_device</span><span class="op">;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Queue families for different workloads</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    vk<span class="op">::</span>Queue <span class="va">m_graphics_queue</span><span class="op">;</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    vk<span class="op">::</span>Queue <span class="va">m_compute_queue</span><span class="op">;</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    vk<span class="op">::</span>Queue <span class="va">m_transfer_queue</span><span class="op">;</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Resource management</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>VKMemoryAllocator<span class="op">&gt;</span> <span class="va">m_allocator</span><span class="op">;</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>VKCommandPoolManager<span class="op">&gt;</span> <span class="va">m_command_pools</span><span class="op">;</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>VKDescriptorManager<span class="op">&gt;</span> <span class="va">m_descriptors</span><span class="op">;</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><strong>Key responsibilities:</strong></p>
<ul>
<li>Device selection and capability querying</li>
<li>Queue family management (graphics, compute, transfer)</li>
<li>Memory allocation and mapping</li>
<li>Command buffer lifecycle</li>
<li>Synchronization primitives (semaphores, fences)</li>
</ul>
<h3 id="vkbuffer-semantic-gpu-memory">VKBuffer: Semantic GPU Memory</h3>
<p><code>VKBuffer</code> is a first-class member of the Buffer
processing chain, parallel to <code>AudioBuffer</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> VKBuffer <span class="op">:</span> <span class="kw">public</span> Buffer <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> <span class="kw">class</span> Usage <span class="op">{</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        STAGING<span class="op">,</span>   <span class="co">// Host-visible staging buffer (CPU-writable)</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>        DEVICE<span class="op">,</span>    <span class="co">// Device-local GPU-only buffer</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>        COMPUTE<span class="op">,</span>   <span class="co">// Storage buffer for compute shaders</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>        VERTEX<span class="op">,</span>    <span class="co">// Vertex buffer</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>        INDEX<span class="op">,</span>     <span class="co">// Index buffer</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>        UNIFORM    <span class="co">// Uniform buffer (host-visible when requested)</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    VKBuffer<span class="op">(</span><span class="dt">size_t</span> size_bytes<span class="op">,</span> Usage usage<span class="op">,</span> Kakshya<span class="op">::</span>DataModality modality<span class="op">);</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Inherited from Buffer - integrates with processing chains</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> set_default_processor<span class="op">(</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>BufferProcessor<span class="op">&gt;</span> processor<span class="op">)</span> <span class="kw">override</span><span class="op">;</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>BufferProcessingChain<span class="op">&gt;</span> get_processing_chain<span class="op">()</span> <span class="kw">override</span><span class="op">;</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// GPU-specific access</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    vk<span class="op">::</span>Buffer get_vulkan_buffer<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span><span class="op">*</span> map_memory<span class="op">();</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> unmap_memory<span class="op">();</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Semantic layout for vertex data</span></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> set_vertex_layout<span class="op">(</span><span class="at">const</span> Kakshya<span class="op">::</span>VertexLayout<span class="op">&amp;</span> layout<span class="op">);</span></span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>optional<span class="op">&lt;</span>Kakshya<span class="op">::</span>VertexLayout<span class="op">&gt;</span> get_vertex_layout<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><strong>Key insight:</strong> VKBuffer carries <strong>semantic
metadata</strong> (modality, dimensions, vertex attributes) alongside
Vulkan handles. This enables grammar-based processors to inspect buffer
characteristics and select appropriate operations—just like audio
buffers.</p>
<p><strong>Usage pattern:</strong></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Create vertex buffer with semantic layout</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> vertex_buffer <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>VKBuffer<span class="op">&gt;(</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    vertex_count <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span>Vertex<span class="op">),</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    VKBuffer<span class="op">::</span>Usage<span class="op">::</span>VERTEX<span class="op">,</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    Kakshya<span class="op">::</span>DataModality<span class="op">::</span>VERTEX_BUFFER</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>Kakshya<span class="op">::</span>VertexLayout layout<span class="op">;</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>layout<span class="op">.</span>add_attribute<span class="op">(</span><span class="st">&quot;position&quot;</span><span class="op">,</span> Kakshya<span class="op">::</span>AttributeFormat<span class="op">::</span>FLOAT3<span class="op">);</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>layout<span class="op">.</span>add_attribute<span class="op">(</span><span class="st">&quot;color&quot;</span><span class="op">,</span> Kakshya<span class="op">::</span>AttributeFormat<span class="op">::</span>FLOAT4<span class="op">);</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>layout<span class="op">.</span>vertex_count <span class="op">=</span> vertex_count<span class="op">;</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>vertex_buffer<span class="op">-&gt;</span>set_vertex_layout<span class="op">(</span>layout<span class="op">);</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a><span class="co">// Register with graphics domain</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>buffer_manager<span class="op">-&gt;</span>add_buffer<span class="op">(</span>vertex_buffer<span class="op">,</span> ProcessingToken<span class="op">::</span>GRAPHICS_BACKEND<span class="op">);</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a><span class="co">// Attach processor for rendering</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> render_processor <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>RenderProcessor<span class="op">&gt;(</span>config<span class="op">);</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>vertex_buffer<span class="op">-&gt;</span>get_processing_chain<span class="op">()-&gt;</span>add_processor<span class="op">(</span>render_processor<span class="op">);</span></span></code></pre></div>
<h3 id="portal-coordination-layer">Portal Coordination Layer</h3>
<p>The <strong>Portal</strong> namespace provides high-level
coordination between core Vulkan infrastructure and MayaFlux
abstractions. It’s the glue layer that makes GPU processing feel like
audio processing—composable, declarative, and integrated with the
broader system.</p>
<h4 id="shaderfoundry-compilation-and-resource-management">ShaderFoundry:
Compilation and Resource Management</h4>
<p><code>ShaderFoundry</code> manages shader lifecycle, compilation, and
caching:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ShaderFoundry <span class="op">{</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Load and compile shader</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    ShaderID load_shader<span class="op">(</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> filepath<span class="op">,</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>        ShaderStage stage <span class="op">=</span> ShaderStage<span class="op">::</span>AUTO_DETECT<span class="op">,</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> entry_point <span class="op">=</span> <span class="st">&quot;main&quot;</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">);</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Compile from source code</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    ShaderID compile_from_source<span class="op">(</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> source<span class="op">,</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>        ShaderStage stage<span class="op">,</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> entry_point <span class="op">=</span> <span class="st">&quot;main&quot;</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">);</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Get compiled shader module</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>VKShaderModule<span class="op">&gt;</span> get_shader<span class="op">(</span>ShaderID id<span class="op">);</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Hot-reload support</span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> watch_shader<span class="op">(</span>ShaderID id<span class="op">);</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> reload_shader<span class="op">(</span>ShaderID id<span class="op">);</span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Reflection data extraction</span></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>    ShaderReflectionInfo get_reflection_info<span class="op">(</span>ShaderID id<span class="op">);</span></span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Command buffer management (used by processors)</span></span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>    CommandBufferID begin_commands<span class="op">(</span>CommandBufferType type<span class="op">);</span></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>    vk<span class="op">::</span>CommandBuffer get_command_buffer<span class="op">(</span>CommandBufferID id<span class="op">);</span></span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> submit_commands<span class="op">(</span>CommandBufferID id<span class="op">);</span></span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> submit_and_present<span class="op">(</span>CommandBufferID id<span class="op">);</span></span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><strong>Key capabilities:</strong></p>
<ul>
<li><strong>Auto-detection</strong>: Infers shader stage from file
extension (<code>.comp</code>, <code>.vert</code>,
<code>.frag</code>)</li>
<li><strong>SPIR-V compilation</strong>: Compiles GLSL to SPIR-V using
glslang</li>
<li><strong>Caching</strong>: Avoids redundant compilation</li>
<li><strong>Hot-reload</strong>: Watch files and recompile on
changes</li>
<li><strong>Reflection</strong>: Extract descriptor bindings, push
constants, workgroup sizes</li>
</ul>
<p><strong>Usage example:</strong></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span><span class="op">&amp;</span> foundry <span class="op">=</span> Portal<span class="op">::</span>Graphics<span class="op">::</span>get_shader_foundry<span class="op">();</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Load compute shader</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> shader_id <span class="op">=</span> foundry<span class="op">.</span>load_shader<span class="op">(</span><span class="st">&quot;shaders/audio_fft.comp&quot;</span><span class="op">);</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Get reflection info</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> reflection <span class="op">=</span> foundry<span class="op">.</span>get_reflection_info<span class="op">(</span>shader_id<span class="op">);</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Workgroup size: &quot;</span> </span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>          <span class="op">&lt;&lt;</span> reflection<span class="op">.</span>workgroup_size<span class="op">-&gt;</span>at<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;x&quot;</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>          <span class="op">&lt;&lt;</span> reflection<span class="op">.</span>workgroup_size<span class="op">-&gt;</span>at<span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;x&quot;</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>          <span class="op">&lt;&lt;</span> reflection<span class="op">.</span>workgroup_size<span class="op">-&gt;</span>at<span class="op">(</span><span class="dv">2</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span></code></pre></div>
<h4 id="computepress-compute-shader-dispatch">ComputePress: Compute
Shader Dispatch</h4>
<p><code>ComputePress</code> coordinates compute pipeline creation and
dispatch:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ComputePress <span class="op">{</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Create compute pipeline</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    ComputePipelineID create_pipeline<span class="op">(</span><span class="at">const</span> ComputePipelineConfig<span class="op">&amp;</span> config<span class="op">);</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Dispatch compute work</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> dispatch<span class="op">(</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>        CommandBufferID cmd_id<span class="op">,</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>        ComputePipelineID pipeline_id<span class="op">,</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uint32_t</span> group_count_x<span class="op">,</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uint32_t</span> group_count_y <span class="op">=</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uint32_t</span> group_count_z <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">);</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Bind resources</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> bind_descriptor_sets<span class="op">(</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>        CommandBufferID cmd_id<span class="op">,</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>        ComputePipelineID pipeline_id<span class="op">,</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>DescriptorSetID<span class="op">&gt;&amp;</span> sets</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">);</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Update push constants</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> push_constants<span class="op">(</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>        CommandBufferID cmd_id<span class="op">,</span></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>        ComputePipelineID pipeline_id<span class="op">,</span></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="dt">void</span><span class="op">*</span> data<span class="op">,</span></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>        <span class="dt">size_t</span> size</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">);</span></span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><strong>Usage in ComputeProcessor:</strong></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ComputeProcessor <span class="op">:</span> <span class="kw">public</span> ShaderProcessor <span class="op">{</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> processing_function<span class="op">(</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Buffer<span class="op">&gt;</span> buffer<span class="op">)</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> vk_buffer <span class="op">=</span> <span class="bu">std::</span>dynamic_pointer_cast<span class="op">&lt;</span>VKBuffer<span class="op">&gt;(</span>buffer<span class="op">);</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span><span class="op">&amp;</span> foundry <span class="op">=</span> Portal<span class="op">::</span>Graphics<span class="op">::</span>get_shader_foundry<span class="op">();</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span><span class="op">&amp;</span> compute <span class="op">=</span> Portal<span class="op">::</span>Graphics<span class="op">::</span>get_compute_press<span class="op">();</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Begin command recording</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> cmd_id <span class="op">=</span> foundry<span class="op">.</span>begin_commands<span class="op">(</span>CommandBufferType<span class="op">::</span>COMPUTE<span class="op">);</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Bind pipeline and resources</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>        compute<span class="op">.</span>bind_pipeline<span class="op">(</span>cmd_id<span class="op">,</span> <span class="va">m_pipeline_id</span><span class="op">);</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>        compute<span class="op">.</span>bind_descriptor_sets<span class="op">(</span>cmd_id<span class="op">,</span> <span class="va">m_pipeline_id</span><span class="op">,</span> <span class="va">m_descriptor_sets</span><span class="op">);</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Push constants (if any)</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="va">m_has_push_constants</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>            compute<span class="op">.</span>push_constants<span class="op">(</span>cmd_id<span class="op">,</span> <span class="va">m_pipeline_id</span><span class="op">,</span> <span class="op">&amp;</span><span class="va">m_push_data</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="va">m_push_data</span><span class="op">));</span></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Dispatch compute work</span></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uint32_t</span> workgroup_count <span class="op">=</span> <span class="op">(</span>vk_buffer<span class="op">-&gt;</span>size<span class="op">()</span> <span class="op">+</span> <span class="va">m_workgroup_size</span> <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">/</span> <span class="va">m_workgroup_size</span><span class="op">;</span></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>        compute<span class="op">.</span>dispatch<span class="op">(</span>cmd_id<span class="op">,</span> <span class="va">m_pipeline_id</span><span class="op">,</span> workgroup_count<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Submit to GPU</span></span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a>        foundry<span class="op">.</span>submit_commands<span class="op">(</span>cmd_id<span class="op">);</span></span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h4 id="renderflow-graphics-pipeline-management">RenderFlow: Graphics
Pipeline Management</h4>
<p><code>RenderFlow</code> coordinates graphics (not compute) pipeline
creation and rendering:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> RenderFlow <span class="op">{</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Create render pass</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    RenderPassID create_render_pass<span class="op">(</span><span class="at">const</span> RenderPassConfig<span class="op">&amp;</span> config<span class="op">);</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    RenderPassID create_simple_render_pass<span class="op">();</span>  <span class="co">// Default color+depth</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Create graphics pipeline</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    RenderPipelineID create_pipeline<span class="op">(</span><span class="at">const</span> RenderPipelineConfig<span class="op">&amp;</span> config<span class="op">);</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Begin/end render pass</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> begin_render_pass<span class="op">(</span>CommandBufferID cmd_id<span class="op">,</span> <span class="at">const</span> <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Window<span class="op">&gt;&amp;</span> window<span class="op">);</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> end_render_pass<span class="op">(</span>CommandBufferID cmd_id<span class="op">);</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Bind pipeline and resources</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> bind_pipeline<span class="op">(</span>CommandBufferID cmd_id<span class="op">,</span> RenderPipelineID pipeline_id<span class="op">);</span></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> bind_vertex_buffers<span class="op">(</span>CommandBufferID cmd_id<span class="op">,</span> <span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>VKBuffer<span class="op">&gt;&gt;&amp;</span> buffers<span class="op">);</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> bind_index_buffer<span class="op">(</span>CommandBufferID cmd_id<span class="op">,</span> <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>VKBuffer<span class="op">&gt;</span> buffer<span class="op">);</span></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw commands</span></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> draw<span class="op">(</span>CommandBufferID cmd_id<span class="op">,</span> <span class="dt">uint32_t</span> vertex_count<span class="op">,</span> <span class="dt">uint32_t</span> instance_count <span class="op">=</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> draw_indexed<span class="op">(</span>CommandBufferID cmd_id<span class="op">,</span> <span class="dt">uint32_t</span> index_count<span class="op">);</span></span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Window integration</span></span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> register_window_for_rendering<span class="op">(</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Window<span class="op">&gt;</span> window<span class="op">,</span> RenderPassID render_pass<span class="op">);</span></span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> present_rendered_image<span class="op">(</span>CommandBufferID cmd_id<span class="op">,</span> <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Window<span class="op">&gt;</span> window<span class="op">);</span></span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><strong>RenderProcessor usage:</strong></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> RenderProcessor <span class="op">:</span> <span class="kw">public</span> ShaderProcessor <span class="op">{</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> processing_function<span class="op">(</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Buffer<span class="op">&gt;</span> buffer<span class="op">)</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> vk_buffer <span class="op">=</span> <span class="bu">std::</span>dynamic_pointer_cast<span class="op">&lt;</span>VKBuffer<span class="op">&gt;(</span>buffer<span class="op">);</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span><span class="op">&amp;</span> foundry <span class="op">=</span> Portal<span class="op">::</span>Graphics<span class="op">::</span>get_shader_foundry<span class="op">();</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span><span class="op">&amp;</span> flow <span class="op">=</span> Portal<span class="op">::</span>Graphics<span class="op">::</span>get_render_flow<span class="op">();</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Begin command recording</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> cmd_id <span class="op">=</span> foundry<span class="op">.</span>begin_commands<span class="op">(</span>CommandBufferType<span class="op">::</span>GRAPHICS<span class="op">);</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Begin render pass (automatically gets framebuffer from window)</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>        flow<span class="op">.</span>begin_render_pass<span class="op">(</span>cmd_id<span class="op">,</span> <span class="va">m_target_window</span><span class="op">);</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Set viewport/scissor</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uint32_t</span> width<span class="op">,</span> height<span class="op">;</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>        get_swapchain_extent<span class="op">(</span><span class="va">m_target_window</span><span class="op">,</span> width<span class="op">,</span> height<span class="op">);</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>        set_viewport<span class="op">(</span>cmd_id<span class="op">,</span> width<span class="op">,</span> height<span class="op">);</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Bind pipeline and vertex buffer</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>        flow<span class="op">.</span>bind_pipeline<span class="op">(</span>cmd_id<span class="op">,</span> <span class="va">m_render_pipeline_id</span><span class="op">);</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>        flow<span class="op">.</span>bind_vertex_buffers<span class="op">(</span>cmd_id<span class="op">,</span> <span class="op">{</span>vk_buffer<span class="op">});</span></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Draw</span></span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> vertex_layout <span class="op">=</span> vk_buffer<span class="op">-&gt;</span>get_vertex_layout<span class="op">();</span></span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>        flow<span class="op">.</span>draw<span class="op">(</span>cmd_id<span class="op">,</span> vertex_layout<span class="op">-&gt;</span>vertex_count<span class="op">);</span></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>        <span class="co">// End render pass</span></span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>        flow<span class="op">.</span>end_render_pass<span class="op">(</span>cmd_id<span class="op">);</span></span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Store command buffer for presentation</span></span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a>        vk_buffer<span class="op">-&gt;</span>set_pipeline_command<span class="op">(</span><span class="va">m_render_pipeline_id</span><span class="op">,</span> cmd_id<span class="op">);</span></span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><strong>Key architectural insight:</strong> <code>ComputePress</code>
and <code>RenderFlow</code> provide <strong>parallel
abstractions</strong> for compute vs graphics workloads, but both
integrate seamlessly with the same <code>VKBuffer</code> and
<code>BufferProcessingChain</code> infrastructure.</p>
<h3 id="multi-stage-pipeline-support">Multi-Stage Pipeline Support</h3>
<p>MayaFlux supports the full graphics pipeline with multiple shader
stages:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Create multi-stage graphics pipeline</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>RenderPipelineConfig config<span class="op">;</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>config<span class="op">.</span>vertex_shader <span class="op">=</span> foundry<span class="op">.</span>load_shader<span class="op">(</span><span class="st">&quot;shaders/vertex.vert&quot;</span><span class="op">);</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>config<span class="op">.</span>fragment_shader <span class="op">=</span> foundry<span class="op">.</span>load_shader<span class="op">(</span><span class="st">&quot;shaders/fragment.frag&quot;</span><span class="op">);</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>config<span class="op">.</span>geometry_shader <span class="op">=</span> foundry<span class="op">.</span>load_shader<span class="op">(</span><span class="st">&quot;shaders/geometry.geom&quot;</span><span class="op">);</span>  <span class="co">// Optional</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>config<span class="op">.</span>tess_control_shader <span class="op">=</span> foundry<span class="op">.</span>load_shader<span class="op">(</span><span class="st">&quot;shaders/tess_ctrl.tesc&quot;</span><span class="op">);</span>  <span class="co">// Optional</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>config<span class="op">.</span>tess_eval_shader <span class="op">=</span> foundry<span class="op">.</span>load_shader<span class="op">(</span><span class="st">&quot;shaders/tess_eval.tese&quot;</span><span class="op">);</span>  <span class="co">// Optional</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Vertex input from semantic layout</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>config<span class="op">.</span>vertex_bindings <span class="op">=</span> <span class="op">{{</span><span class="dv">0</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>Vertex<span class="op">),</span> vk<span class="op">::</span>VertexInputRate<span class="op">::</span>eVertex<span class="op">}};</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>config<span class="op">.</span>vertex_attributes <span class="op">=</span> <span class="op">{</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> vk<span class="op">::</span>Format<span class="op">::</span>eR32G32B32Sfloat<span class="op">,</span> offsetof<span class="op">(</span>Vertex<span class="op">,</span> position<span class="op">)},</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> vk<span class="op">::</span>Format<span class="op">::</span>eR32G32B32A32Sfloat<span class="op">,</span> offsetof<span class="op">(</span>Vertex<span class="op">,</span> color<span class="op">)},</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> vk<span class="op">::</span>Format<span class="op">::</span>eR32G32Sfloat<span class="op">,</span> offsetof<span class="op">(</span>Vertex<span class="op">,</span> texcoord<span class="op">)}</span></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a><span class="co">// Rasterization state</span></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>config<span class="op">.</span>topology <span class="op">=</span> vk<span class="op">::</span>PrimitiveTopology<span class="op">::</span>eTriangleList<span class="op">;</span></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>config<span class="op">.</span>polygon_mode <span class="op">=</span> vk<span class="op">::</span>PolygonMode<span class="op">::</span>eFill<span class="op">;</span></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>config<span class="op">.</span>cull_mode <span class="op">=</span> vk<span class="op">::</span>CullModeFlagBits<span class="op">::</span>eBack<span class="op">;</span></span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a><span class="co">// Blending</span></span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a>config<span class="op">.</span>enable_alpha_blending<span class="op">();</span></span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> pipeline_id <span class="op">=</span> flow<span class="op">.</span>create_pipeline<span class="op">(</span>config<span class="op">);</span></span></code></pre></div>
<p><strong>Or using RenderProcessor fluent API:</strong></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> render_proc <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>RenderProcessor<span class="op">&gt;(</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    ShaderProcessorConfig<span class="op">{.</span>shader_path <span class="op">=</span> <span class="st">&quot;shaders/vertex.vert&quot;</span><span class="op">}</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>render_proc<span class="op">-&gt;</span>set_fragment_shader<span class="op">(</span><span class="st">&quot;shaders/fragment.frag&quot;</span><span class="op">);</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>render_proc<span class="op">-&gt;</span>set_geometry_shader<span class="op">(</span><span class="st">&quot;shaders/geometry.geom&quot;</span><span class="op">);</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>render_proc<span class="op">-&gt;</span>set_render_pass<span class="op">(</span>render_pass_id<span class="op">);</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>render_proc<span class="op">-&gt;</span>set_target_window<span class="op">(</span>my_window<span class="op">);</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>vertex_buffer<span class="op">-&gt;</span>get_processing_chain<span class="op">()-&gt;</span>add_processor<span class="op">(</span>render_proc<span class="op">);</span></span></code></pre></div>
<h3 id="window-integration-and-presentation">Window Integration and
Presentation</h3>
<p>Windows are first-class rendering targets integrated with the buffer
system:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Create window</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> window <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>GlfwWindow<span class="op">&gt;(</span>WindowCreateInfo<span class="op">{</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>width <span class="op">=</span> <span class="dv">1920</span><span class="op">,</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>height <span class="op">=</span> <span class="dv">1080</span><span class="op">,</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>title <span class="op">=</span> <span class="st">&quot;MayaFlux Visual Output&quot;</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="op">});</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Register window with graphics system</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>graphics_subsystem<span class="op">-&gt;</span>register_window<span class="op">(</span>window<span class="op">);</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a><span class="co">// Create render pass for this window</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> render_pass <span class="op">=</span> flow<span class="op">.</span>create_simple_render_pass<span class="op">();</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>flow<span class="op">.</span>register_window_for_rendering<span class="op">(</span>window<span class="op">,</span> render_pass<span class="op">);</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a><span class="co">// Attach RenderProcessor to buffer with this window as target</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>render_processor<span class="op">-&gt;</span>set_target_window<span class="op">(</span>window<span class="op">);</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>render_processor<span class="op">-&gt;</span>set_render_pass<span class="op">(</span>render_pass<span class="op">);</span></span></code></pre></div>
<p><strong>DisplayService</strong> (in the Registry) handles swapchain
management, framebuffer creation, and presentation:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DisplayService <span class="op">{</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Register window for graphics</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> register_window<span class="op">(</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Window<span class="op">&gt;</span> window<span class="op">);</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Attach render pass to window (creates framebuffers)</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> attach_render_pass<span class="op">(</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Window<span class="op">&gt;</span> window<span class="op">,</span> </span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>                           <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>VKRenderPass<span class="op">&gt;</span> render_pass<span class="op">);</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Get swapchain extent for viewport setup</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> get_swapchain_extent<span class="op">(</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Window<span class="op">&gt;</span> window<span class="op">,</span> </span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>                             <span class="dt">uint32_t</span><span class="op">&amp;</span> width<span class="op">,</span> <span class="dt">uint32_t</span><span class="op">&amp;</span> height<span class="op">);</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Present frame (called by RenderFlow)</span></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> present_frame<span class="op">(</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Window<span class="op">&gt;</span> window<span class="op">,</span> <span class="dt">uint64_t</span> cmd_buffer_bits<span class="op">);</span></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="complete-rendering-example">Complete Rendering Example</h3>
<p>Here’s a full working example of graphics processing in MayaFlux:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Setup</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span><span class="op">&amp;</span> foundry <span class="op">=</span> Portal<span class="op">::</span>Graphics<span class="op">::</span>get_shader_foundry<span class="op">();</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span><span class="op">&amp;</span> flow <span class="op">=</span> Portal<span class="op">::</span>Graphics<span class="op">::</span>get_render_flow<span class="op">();</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> buffer_manager <span class="op">=</span> MayaFlux<span class="op">::</span>get_buffer_manager<span class="op">();</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Create window and render pass</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> window <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>GlfwWindow<span class="op">&gt;(</span>WindowCreateInfo<span class="op">{</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>width <span class="op">=</span> <span class="dv">1280</span><span class="op">,</span> <span class="op">.</span>height <span class="op">=</span> <span class="dv">720</span><span class="op">,</span> <span class="op">.</span>title <span class="op">=</span> <span class="st">&quot;Graphics Demo&quot;</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a><span class="op">});</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> render_pass <span class="op">=</span> flow<span class="op">.</span>create_simple_render_pass<span class="op">();</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>flow<span class="op">.</span>register_window_for_rendering<span class="op">(</span>window<span class="op">,</span> render_pass<span class="op">);</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a><span class="co">// Create vertex buffer with semantic layout</span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>Vertex<span class="op">&gt;</span> vertices <span class="op">=</span> generate_triangle_vertices<span class="op">();</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> vertex_buffer <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>VKBuffer<span class="op">&gt;(</span></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>    vertices<span class="op">.</span>size<span class="op">()</span> <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span>Vertex<span class="op">),</span></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>    VKBuffer<span class="op">::</span>Usage<span class="op">::</span>VERTEX<span class="op">,</span></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>    Kakshya<span class="op">::</span>DataModality<span class="op">::</span>VERTEX_BUFFER</span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a>Kakshya<span class="op">::</span>VertexLayout layout<span class="op">;</span></span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>layout<span class="op">.</span>add_attribute<span class="op">(</span><span class="st">&quot;position&quot;</span><span class="op">,</span> Kakshya<span class="op">::</span>AttributeFormat<span class="op">::</span>FLOAT3<span class="op">);</span></span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a>layout<span class="op">.</span>add_attribute<span class="op">(</span><span class="st">&quot;color&quot;</span><span class="op">,</span> Kakshya<span class="op">::</span>AttributeFormat<span class="op">::</span>FLOAT4<span class="op">);</span></span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a>layout<span class="op">.</span>vertex_count <span class="op">=</span> vertices<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a>vertex_buffer<span class="op">-&gt;</span>set_vertex_layout<span class="op">(</span>layout<span class="op">);</span></span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a><span class="co">// Upload vertex data</span></span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span><span class="op">*</span> mapped <span class="op">=</span> vertex_buffer<span class="op">-&gt;</span>map_memory<span class="op">();</span></span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>memcpy<span class="op">(</span>mapped<span class="op">,</span> vertices<span class="op">.</span>data<span class="op">(),</span> vertices<span class="op">.</span>size<span class="op">()</span> <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span>Vertex<span class="op">));</span></span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a>vertex_buffer<span class="op">-&gt;</span>unmap_memory<span class="op">();</span></span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-32"><a href="#cb30-32" aria-hidden="true" tabindex="-1"></a><span class="co">// Create render processor</span></span>
<span id="cb30-33"><a href="#cb30-33" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> render_proc <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>RenderProcessor<span class="op">&gt;(</span></span>
<span id="cb30-34"><a href="#cb30-34" aria-hidden="true" tabindex="-1"></a>    ShaderProcessorConfig<span class="op">{.</span>shader_path <span class="op">=</span> <span class="st">&quot;shaders/simple.vert&quot;</span><span class="op">}</span></span>
<span id="cb30-35"><a href="#cb30-35" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span>
<span id="cb30-36"><a href="#cb30-36" aria-hidden="true" tabindex="-1"></a>render_proc<span class="op">-&gt;</span>set_fragment_shader<span class="op">(</span><span class="st">&quot;shaders/simple.frag&quot;</span><span class="op">);</span></span>
<span id="cb30-37"><a href="#cb30-37" aria-hidden="true" tabindex="-1"></a>render_proc<span class="op">-&gt;</span>set_render_pass<span class="op">(</span>render_pass<span class="op">);</span></span>
<span id="cb30-38"><a href="#cb30-38" aria-hidden="true" tabindex="-1"></a>render_proc<span class="op">-&gt;</span>set_target_window<span class="op">(</span>window<span class="op">);</span></span>
<span id="cb30-39"><a href="#cb30-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-40"><a href="#cb30-40" aria-hidden="true" tabindex="-1"></a><span class="co">// Register buffer with processor</span></span>
<span id="cb30-41"><a href="#cb30-41" aria-hidden="true" tabindex="-1"></a>buffer_manager<span class="op">-&gt;</span>add_buffer<span class="op">(</span>vertex_buffer<span class="op">,</span> ProcessingToken<span class="op">::</span>GRAPHICS_BACKEND<span class="op">);</span></span>
<span id="cb30-42"><a href="#cb30-42" aria-hidden="true" tabindex="-1"></a>vertex_buffer<span class="op">-&gt;</span>get_processing_chain<span class="op">()-&gt;</span>add_processor<span class="op">(</span>render_proc<span class="op">);</span></span>
<span id="cb30-43"><a href="#cb30-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-44"><a href="#cb30-44" aria-hidden="true" tabindex="-1"></a><span class="co">// Graphics loop (simplified)</span></span>
<span id="cb30-45"><a href="#cb30-45" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>window<span class="op">-&gt;</span>is_open<span class="op">())</span> <span class="op">{</span></span>
<span id="cb30-46"><a href="#cb30-46" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Process graphics buffers (executes render processor)</span></span>
<span id="cb30-47"><a href="#cb30-47" aria-hidden="true" tabindex="-1"></a>    buffer_manager<span class="op">-&gt;</span>process_graphics_buffers<span class="op">(</span>ProcessingToken<span class="op">::</span>GRAPHICS_BACKEND<span class="op">);</span></span>
<span id="cb30-48"><a href="#cb30-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-49"><a href="#cb30-49" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Present (done inside PresentProcessor after all rendering)</span></span>
<span id="cb30-50"><a href="#cb30-50" aria-hidden="true" tabindex="-1"></a>    <span class="co">// flow.present_rendered_image() called automatically</span></span>
<span id="cb30-51"><a href="#cb30-51" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="cross-domain-coordination-patterns-conceptual">Cross-Domain
Coordination Patterns (Conceptual)</h3>
<p>While full audio-visual coordination workflows are still being
developed, the architecture enables patterns like:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Audio analysis feeding compute shader (conceptual)</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> spectral_analyzer <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>SpectralAnalyzer<span class="op">&gt;();</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>audio_buffer<span class="op">-&gt;</span>get_processing_chain<span class="op">()-&gt;</span>add_processor<span class="op">(</span>spectral_analyzer<span class="op">);</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> visual_modulator <span class="op">=</span> Kriya<span class="op">::</span>metro<span class="op">(*</span>scheduler<span class="op">,</span> <span class="fl">0.016</span><span class="op">,</span> <span class="op">[&amp;]()</span> <span class="op">{</span>  <span class="co">// ~60 FPS</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Get spectral data from audio processing</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> spectrum <span class="op">=</span> spectral_analyzer<span class="op">-&gt;</span>get_current_spectrum<span class="op">();</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Update compute shader push constants</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>    ComputeShaderParams params<span class="op">;</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>    params<span class="op">.</span>bass_energy <span class="op">=</span> spectrum<span class="op">.</span>energy_in_range<span class="op">(</span><span class="dv">20</span><span class="op">,</span> <span class="dv">200</span><span class="op">);</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>    params<span class="op">.</span>mid_energy <span class="op">=</span> spectrum<span class="op">.</span>energy_in_range<span class="op">(</span><span class="dv">200</span><span class="op">,</span> <span class="dv">2000</span><span class="op">);</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Compute shader processes visual buffer based on audio features</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>    compute_processor<span class="op">-&gt;</span>update_push_constants<span class="op">(&amp;</span>params<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>params<span class="op">));</span></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a><span class="op">});</span></span></code></pre></div>
<p>The infrastructure for this exists—unified buffer abstractions,
processing chains, coroutine coordination—but concrete production
examples are still being developed.</p>
<hr />
<h2 id="yantra-pipeline-declarative-transformation-composition">Yantra
Pipeline: Declarative Transformation Composition</h2>
<p>Yantra provides the transformation infrastructure that works with
ComputationGrammar. The <strong>architecture is complete and
proven</strong>—transformer hierarchy, declarative composition,
integration with grammar-based pipelines. Specific algorithmic
implementations are in active development.</p>
<h3 id="transformer-hierarchy">Transformer Hierarchy</h3>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Base transformer interface</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>ComputeData InputType<span class="op">,</span> ComputeData OutputType<span class="op">&gt;</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> UniversalTransformer <span class="op">{</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> TransformationType <span class="dt">get_transformation_type</span><span class="op">()</span> <span class="at">const</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> IO<span class="op">&lt;</span>OutputType<span class="op">&gt;</span> apply_operation<span class="op">(</span><span class="at">const</span> IO<span class="op">&lt;</span>InputType<span class="op">&gt;&amp;</span> input<span class="op">)</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Chainable composition</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> NextTransformer<span class="op">&gt;</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> chain<span class="op">(</span>NextTransformer<span class="op">&amp;&amp;</span> next<span class="op">)</span> <span class="op">{</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ComposedTransformer<span class="op">(*</span><span class="kw">this</span><span class="op">,</span> <span class="bu">std::</span>forward<span class="op">&lt;</span>NextTransformer<span class="op">&gt;(</span>next<span class="op">));</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a><span class="co">// Concrete implementations</span></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="kw">class</span> TransformationType <span class="op">{</span></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>    MATHEMATICAL<span class="op">,</span>  <span class="co">// Normalization, scaling, polynomial</span></span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>    TEMPORAL<span class="op">,</span>      <span class="co">// Reversal, time-stretch, delay</span></span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>    SPECTRAL<span class="op">,</span>      <span class="co">// FFT, filtering, phase manipulation</span></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>    STRUCTURAL     <span class="co">// Reshaping, dimensional transforms</span></span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="declarative-composition-showcase">Declarative Composition
Showcase</h3>
<p>The core expressive power of Yantra is <strong>declarative pipeline
construction</strong>:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Manual chaining</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> pipeline <span class="op">=</span> normalizer</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>chain<span class="op">(</span>time_reverser<span class="op">)</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>chain<span class="op">(</span>spectral_filter<span class="op">)</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>chain<span class="op">(</span>fade_envelope<span class="op">);</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result <span class="op">=</span> pipeline<span class="op">.</span>apply_operation<span class="op">(</span>input_data<span class="op">);</span></span></code></pre></div>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Grammar-based automatic selection</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> adaptive_pipeline <span class="op">=</span> ComputationPipeline<span class="op">(</span>grammar<span class="op">)</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>add_input<span class="op">(</span>input_data<span class="op">)</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>with_context<span class="op">(</span>ComputationContext<span class="op">::</span>TEMPORAL<span class="op">)</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>with_parameter<span class="op">(</span><span class="st">&quot;window_size&quot;</span><span class="op">,</span> <span class="dv">1024</span><span class="op">)</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>execute<span class="op">();</span></span></code></pre></div>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Operator-based fluent syntax</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> result <span class="op">=</span> input_data </span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> normalize<span class="op">()</span> </span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> reverse_time<span class="op">()</span> </span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> apply_filter<span class="op">(</span><span class="st">&quot;lowpass&quot;</span><span class="op">,</span> <span class="fl">2000.0</span><span class="op">);</span></span></code></pre></div>
<h3 id="grammar-integration-example">Grammar Integration Example</h3>
<p>This demonstrates the <strong>declarative operation matching</strong>
that makes Yantra powerful:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Define transformation rules</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>grammar<span class="op">.</span>create_rule<span class="op">(</span><span class="st">&quot;normalize_audio&quot;</span><span class="op">)</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>with_context<span class="op">(</span>ComputationContext<span class="op">::</span>MATHEMATICAL<span class="op">)</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="dt">matches_type</span><span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;()</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>executes<span class="op">([](</span><span class="at">const</span> <span class="bu">std::</span>any<span class="op">&amp;</span> input<span class="op">,</span> <span class="at">const</span> ExecutionContext<span class="op">&amp;</span> ctx<span class="op">)</span> <span class="op">{</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> data <span class="op">=</span> <span class="bu">std::</span>any_cast<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;(</span>input<span class="op">);</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> transformer <span class="op">=</span> MathematicalTransformer<span class="op">(</span>MathOperation<span class="op">::</span>NORMALIZE<span class="op">);</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> transformer<span class="op">.</span>apply_operation<span class="op">(</span>IO<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;{</span>data<span class="op">});</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">})</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>build<span class="op">();</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>grammar<span class="op">.</span>create_rule<span class="op">(</span><span class="st">&quot;spectral_process&quot;</span><span class="op">)</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>with_context<span class="op">(</span>ComputationContext<span class="op">::</span>SPECTRAL<span class="op">)</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>matches_custom<span class="op">(</span>spectral_data_matcher<span class="op">)</span></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>executes<span class="op">([](</span><span class="at">const</span> <span class="bu">std::</span>any<span class="op">&amp;</span> input<span class="op">,</span> <span class="at">const</span> ExecutionContext<span class="op">&amp;</span> ctx<span class="op">)</span> <span class="op">{</span></span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> data <span class="op">=</span> <span class="bu">std::</span>any_cast<span class="op">&lt;</span>SpectralData<span class="op">&gt;(</span>input<span class="op">);</span></span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> transformer <span class="op">=</span> SpectralTransformer<span class="op">(</span>SpectralOperation<span class="op">::</span>FILTER<span class="op">);</span></span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> transformer<span class="op">.</span>apply_operation<span class="op">(</span>IO<span class="op">&lt;</span>SpectralData<span class="op">&gt;{</span>data<span class="op">});</span></span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">})</span></span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>build<span class="op">();</span></span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a><span class="co">// Pipeline automatically selects appropriate transformers</span></span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> pipeline <span class="op">=</span> ComputationPipeline<span class="op">(</span>grammar<span class="op">);</span></span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> processed <span class="op">=</span> pipeline</span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>add_input<span class="op">(</span>unknown_data<span class="op">)</span>  <span class="co">// Could be audio, spectral, visual</span></span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>with_context<span class="op">(</span>ComputationContext<span class="op">::</span>AUTO_DETECT<span class="op">)</span></span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>execute<span class="op">();</span>  <span class="co">// Grammar matches rules based on data type and context</span></span></code></pre></div>
<h3 id="implementation-status">Implementation Status</h3>
<p><strong>Architecture:</strong> ✓ Complete and tested - Transformer
hierarchy with type-safe composition - Grammar integration with
rule-based selection - Fluent operator syntax - Pipeline abstraction
with context awareness</p>
<p><strong>Algorithms:</strong> ⚙ In development - Mathematical
operations: Functional (normalize, scale, clamp) - Temporal operations:
Functional (reverse, basic time-stretch) - Spectral operations: Basic
FFT functional, advanced processing planned - Advanced algorithms: Phase
vocoder, granular synthesis, adaptive filtering in development</p>
<p>The <strong>design pattern is proven</strong>—transformers compose
declaratively and integrate with grammar-based pipelines. What remains
is implementing the breadth of algorithmic operations, not validating
the architectural approach.</p>
<hr />
<h2 id="nddata-unified-cross-modal-processing">NDData: Unified
Cross-Modal Processing</h2>
<h3 id="the-problem-1">The Problem</h3>
<p>Traditional multimedia systems treat different data types as
separate:</p>
<ul>
<li>Audio: Samples in time</li>
<li>Images: Pixels in 2D space</li>
<li>Video: Frames over time</li>
<li>Spectral: Frequency over time</li>
<li>Tensors: N-dimensional arrays</li>
</ul>
<p>Each requires different APIs, different processing pipelines,
different transformation logic.</p>
<h3 id="the-solution-dimensional-abstraction">The Solution: Dimensional
Abstraction</h3>
<p>NDData provides <strong>unified dimensional access</strong>
regardless of data modality:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> Kakshya <span class="op">{</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Unified data type</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> DataVariant <span class="op">=</span> <span class="bu">std::</span>variant<span class="op">&lt;</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;,</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">uint32_t</span><span class="op">&gt;,</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span>glm<span class="op">::</span>vec3<span class="op">&gt;</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;;</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a><span class="co">// Dimensional descriptor</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> DataDimension <span class="op">{</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string name<span class="op">;</span>           <span class="co">// &quot;time&quot;, &quot;frequency&quot;, &quot;x&quot;, &quot;y&quot;, &quot;channel&quot;</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> size<span class="op">;</span>              <span class="co">// Number of elements</span></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint64_t</span> stride<span class="op">;</span>            <span class="co">// Memory stride</span></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>    DimensionType type<span class="op">;</span>         <span class="co">// TEMPORAL, SPATIAL, SPECTRAL, CHANNEL</span></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>optional<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> scale<span class="op">;</span> <span class="co">// Physical units conversion</span></span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="data-modality-definitions">Data Modality Definitions</h3>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="kw">class</span> DataModality <span class="op">{</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    AUDIO_1D<span class="op">,</span>              <span class="co">// Single channel audio</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    AUDIO_MULTICHANNEL<span class="op">,</span>    <span class="co">// Multi-channel audio</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    SPECTRAL_2D<span class="op">,</span>           <span class="co">// Frequency x Time</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>    IMAGE_2D<span class="op">,</span>              <span class="co">// Height x Width</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>    IMAGE_RGB<span class="op">,</span>             <span class="co">// Height x Width x 3</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>    VIDEO_3D<span class="op">,</span>              <span class="co">// Height x Width x Time</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>    VERTEX_BUFFER<span class="op">,</span>         <span class="co">// Vertex attributes (graphics)</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>    TENSOR_ND              <span class="co">// Arbitrary dimensions</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="creating-dimensional-data">Creating Dimensional Data</h3>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Audio: 48000 samples</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> audio_module <span class="op">=</span> NDData<span class="op">::</span>create_audio_1d<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(</span><span class="dv">48000</span><span class="op">);</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Multi-channel audio: 48000 samples x 2 channels</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> stereo_module <span class="op">=</span> NDData<span class="op">::</span>create_audio_multichannel<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(</span><span class="dv">48000</span><span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Spectral data: 128 time windows x 1024 frequency bins</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> spectral_module <span class="op">=</span> NDData<span class="op">::</span>create_spectral_2d<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(</span><span class="dv">128</span><span class="op">,</span> <span class="dv">1024</span><span class="op">);</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a><span class="co">// Image: 1920x1080 pixels</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> image_module <span class="op">=</span> NDData<span class="op">::</span>create_image_2d<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(</span><span class="dv">1080</span><span class="op">,</span> <span class="dv">1920</span><span class="op">);</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a><span class="co">// Generic N-dimensional tensor</span></span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> tensor_module <span class="op">=</span> NDData<span class="op">::</span>create_for_modality<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(</span></span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>    DataModality<span class="op">::</span>TENSOR_ND<span class="op">,</span></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span><span class="dv">256</span><span class="op">,</span> <span class="dv">256</span><span class="op">,</span> <span class="dv">64</span><span class="op">},</span>  <span class="co">// shape</span></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>    <span class="fl">0.0</span><span class="op">,</span>             <span class="co">// default value</span></span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>    MemoryLayout<span class="op">::</span>ROW_MAJOR</span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span></code></pre></div>
<h3 id="unified-transformation-interface">Unified Transformation
Interface</h3>
<p>The same transformation operations work across modalities:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Mathematical operations work on any modality</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> normalized <span class="op">=</span> MathematicalTransformer<span class="op">(</span>MathOperation<span class="op">::</span>NORMALIZE<span class="op">)</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>apply_operation<span class="op">(</span>audio_data<span class="op">);</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> normalized_image <span class="op">=</span> MathematicalTransformer<span class="op">(</span>MathOperation<span class="op">::</span>NORMALIZE<span class="op">)</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>apply_operation<span class="op">(</span>image_data<span class="op">);</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Temporal operations on audio</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> reversed_audio <span class="op">=</span> TemporalTransformer<span class="op">(</span>TemporalOperation<span class="op">::</span>TIME_REVERSE<span class="op">)</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>apply_operation<span class="op">(</span>audio_data<span class="op">);</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a><span class="co">// Temporal operations on video (time dimension)</span></span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> reversed_video <span class="op">=</span> TemporalTransformer<span class="op">(</span>TemporalOperation<span class="op">::</span>TIME_REVERSE<span class="op">)</span></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>apply_operation<span class="op">(</span>video_data<span class="op">);</span></span></code></pre></div>
<h3 id="region-based-access">Region-Based Access</h3>
<p>Regions enable precise data selection across dimensions:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Temporal region (audio)</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> intro <span class="op">=</span> Region<span class="op">::</span>audio_span<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">6000</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span>  <span class="co">// First 0.125s, channel 0</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Spatial region (image)</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> top_left <span class="op">=</span> Region<span class="op">::</span>image_rect<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">100</span><span class="op">,</span> <span class="dv">100</span><span class="op">);</span>  <span class="co">// 100x100 pixel region</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Spectral region</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> bass_range <span class="op">=</span> Region<span class="op">::</span>spectral_range<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">100</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">512</span><span class="op">);</span>  <span class="co">// Low frequencies</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a><span class="co">// Multi-dimensional region (video)</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> clip <span class="op">=</span> Region<span class="op">::</span>video_clip<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">100</span><span class="op">,</span> <span class="dv">50</span><span class="op">,</span> <span class="dv">150</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">30</span><span class="op">);</span>  <span class="co">// Spatial crop + temporal clip</span></span></code></pre></div>
<h3 id="graphics-integration">Graphics Integration</h3>
<p>VKBuffer integrates with NDData modality system:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Create vertex buffer with modality</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> vertex_buffer <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>VKBuffer<span class="op">&gt;(</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    size_bytes<span class="op">,</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>    VKBuffer<span class="op">::</span>Usage<span class="op">::</span>VERTEX<span class="op">,</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    Kakshya<span class="op">::</span>DataModality<span class="op">::</span>VERTEX_BUFFER  <span class="co">// Semantic modality</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Vertex layout is a dimensional descriptor</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>Kakshya<span class="op">::</span>VertexLayout layout<span class="op">;</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>layout<span class="op">.</span>add_attribute<span class="op">(</span><span class="st">&quot;position&quot;</span><span class="op">,</span> Kakshya<span class="op">::</span>AttributeFormat<span class="op">::</span>FLOAT3<span class="op">);</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>layout<span class="op">.</span>add_attribute<span class="op">(</span><span class="st">&quot;normal&quot;</span><span class="op">,</span> Kakshya<span class="op">::</span>AttributeFormat<span class="op">::</span>FLOAT3<span class="op">);</span></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>layout<span class="op">.</span>add_attribute<span class="op">(</span><span class="st">&quot;texcoord&quot;</span><span class="op">,</span> Kakshya<span class="op">::</span>AttributeFormat<span class="op">::</span>FLOAT2<span class="op">);</span></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>layout<span class="op">.</span>vertex_count <span class="op">=</span> num_vertices<span class="op">;</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>vertex_buffer<span class="op">-&gt;</span>set_vertex_layout<span class="op">(</span>layout<span class="op">);</span></span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a><span class="co">// Grammar can now match on vertex buffer characteristics</span></span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a>grammar<span class="op">.</span>create_rule<span class="op">(</span><span class="st">&quot;process_vertex_normals&quot;</span><span class="op">)</span></span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>matches_modality<span class="op">(</span>Kakshya<span class="op">::</span>DataModality<span class="op">::</span>VERTEX_BUFFER<span class="op">)</span></span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>matches_attribute<span class="op">(</span><span class="st">&quot;normal&quot;</span><span class="op">)</span></span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>executes<span class="op">(</span>recalculate_normals_operation<span class="op">)</span></span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>build<span class="op">();</span></span></code></pre></div>
<p>This demonstrates <strong>true cross-modal abstraction</strong>—the
same dimensional concepts (modality, attributes, regions) apply to audio
samples, spectral bins, pixels, and vertices.</p>
<h3 id="container-integration">Container Integration</h3>
<p>NDimensionalContainers use regions for creative data
organization:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> NDimensionalContainer <span class="op">{</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Store region with metadata</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> add_region<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> name<span class="op">,</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>                   <span class="at">const</span> Region<span class="op">&amp;</span> region<span class="op">,</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>                   <span class="at">const</span> RegionMetadata<span class="op">&amp;</span> metadata<span class="op">);</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Extract data from region</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>    DataVariant get_region_data<span class="op">(</span><span class="at">const</span> Region<span class="op">&amp;</span> region<span class="op">);</span></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Modify region in place</span></span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> set_region_data<span class="op">(</span><span class="at">const</span> Region<span class="op">&amp;</span> region<span class="op">,</span> <span class="at">const</span> DataVariant<span class="op">&amp;</span> data<span class="op">);</span></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Query regions by attributes</span></span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span>Region<span class="op">&gt;</span> find_regions_with_attribute<span class="op">(</span></span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> key<span class="op">,</span></span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="bu">std::</span>any<span class="op">&amp;</span> value<span class="op">);</span></span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<hr />
<h2 id="window-management-as-coroutines">Window Management as
Coroutines</h2>
<p>MayaFlux reimagines windowing events as <strong>temporal coroutine
patterns</strong> rather than traditional callback spaghetti.</p>
<h3 id="traditional-windowing-callback-hell">Traditional Windowing:
Callback Hell</h3>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Traditional GLFW approach - fragmented callback hell</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> key_callback<span class="op">(</span>GLFWwindow<span class="op">*</span> window<span class="op">,</span> <span class="dt">int</span> key<span class="op">,</span> <span class="dt">int</span> scancode<span class="op">,</span> <span class="dt">int</span> action<span class="op">,</span> <span class="dt">int</span> mods<span class="op">)</span> <span class="op">{</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>action <span class="op">==</span> GLFW_PRESS<span class="op">)</span> <span class="op">{</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>        handle_key_press<span class="op">(</span>key<span class="op">);</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> mouse_callback<span class="op">(</span>GLFWwindow<span class="op">*</span> window<span class="op">,</span> <span class="dt">double</span> xpos<span class="op">,</span> <span class="dt">double</span> ypos<span class="op">)</span> <span class="op">{</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>    handle_mouse_motion<span class="op">(</span>xpos<span class="op">,</span> ypos<span class="op">);</span></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> resize_callback<span class="op">(</span>GLFWwindow<span class="op">*</span> window<span class="op">,</span> <span class="dt">int</span> width<span class="op">,</span> <span class="dt">int</span> height<span class="op">)</span> <span class="op">{</span></span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a>    handle_resize<span class="op">(</span>width<span class="op">,</span> height<span class="op">);</span></span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a><span class="co">// Separate callback registration</span></span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a>glfwSetKeyCallback<span class="op">(</span>window<span class="op">,</span> key_callback<span class="op">);</span></span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true" tabindex="-1"></a>glfwSetCursorPosCallback<span class="op">(</span>window<span class="op">,</span> mouse_callback<span class="op">);</span></span>
<span id="cb44-19"><a href="#cb44-19" aria-hidden="true" tabindex="-1"></a>glfwSetWindowSizeCallback<span class="op">(</span>window<span class="op">,</span> resize_callback<span class="op">);</span></span></code></pre></div>
<p><strong>Problems:</strong></p>
<ul>
<li>State machine logic scattered across callbacks</li>
<li>Difficult to coordinate multi-event patterns</li>
<li>No natural sequencing or temporal coordination</li>
</ul>
<h3 id="mayaflux-approach-window-events-as-eventsource">MayaFlux
Approach: Window Events as EventSource</h3>
<p>Each window has an <code>EventSource</code> that signals events to
coroutines:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> GlfwWindow <span class="op">:</span> <span class="kw">public</span> IWindow <span class="op">{</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>    Vruta<span class="op">::</span>EventSource <span class="va">m_event_source</span><span class="op">;</span>  <span class="co">// Coroutine event signaling</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// GLFW callbacks signal EventSource</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="dt">void</span> glfw_key_callback<span class="op">(</span>GLFWwindow<span class="op">*</span> window<span class="op">,</span> <span class="dt">int</span> key<span class="op">,</span> <span class="dt">int</span> scancode<span class="op">,</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>                                   <span class="dt">int</span> action<span class="op">,</span> <span class="dt">int</span> mods<span class="op">)</span> <span class="op">{</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span><span class="op">*</span> win <span class="op">=</span> <span class="kw">static_cast</span><span class="op">&lt;</span>GlfwWindow<span class="op">*&gt;(</span>glfwGetWindowUserPointer<span class="op">(</span>window<span class="op">));</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>        WindowEvent event<span class="op">;</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>        event<span class="op">.</span>type <span class="op">=</span> <span class="op">(</span>action <span class="op">==</span> GLFW_PRESS<span class="op">)</span> <span class="op">?</span> WindowEventType<span class="op">::</span>KEY_PRESSED</span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>                                            <span class="op">:</span> WindowEventType<span class="op">::</span>KEY_RELEASED<span class="op">;</span></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>        event<span class="op">.</span>timestamp <span class="op">=</span> glfwGetTime<span class="op">();</span></span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>        event<span class="op">.</span>data <span class="op">=</span> WindowEvent<span class="op">::</span>KeyData<span class="op">{</span>key<span class="op">,</span> scancode<span class="op">,</span> mods<span class="op">};</span></span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Signal coroutines waiting on this event</span></span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a>        win<span class="op">-&gt;</span><span class="va">m_event_source</span><span class="op">.</span>signal<span class="op">(</span>event<span class="op">);</span></span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="coroutine-event-patterns">Coroutine Event Patterns</h3>
<h4 id="awaiting-specific-events">Awaiting Specific Events</h4>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Wait for specific window event</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>Event handle_user_input<span class="op">(</span>GlfwWindow<span class="op">&amp;</span> window<span class="op">)</span> <span class="op">{</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Await next keyboard event</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> event <span class="op">=</span> <span class="cf">co_await</span> window<span class="op">.</span>event_source<span class="op">().</span>next_event<span class="op">(</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>            WindowEventType<span class="op">::</span>KEY_PRESSED</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">);</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> key_data <span class="op">=</span> <span class="bu">std::</span>get<span class="op">&lt;</span>WindowEvent<span class="op">::</span>KeyData<span class="op">&gt;(</span>event<span class="op">.</span>data<span class="op">);</span></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>key_data<span class="op">.</span>key <span class="op">==</span> GLFW_KEY_SPACE<span class="op">)</span> <span class="op">{</span></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>            trigger_audio_event<span class="op">();</span></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>key_data<span class="op">.</span>key <span class="op">==</span> GLFW_KEY_ESCAPE<span class="op">)</span> <span class="op">{</span></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="event-driven-audio-visual-coordination">Event-Driven
Audio-Visual Coordination</h4>
<div class="sourceCode" id="cb47"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Coordinate audio triggering with window focus</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>Event focus_aware_processing<span class="op">(</span>GlfwWindow<span class="op">&amp;</span> window<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> event <span class="op">=</span> <span class="cf">co_await</span> window<span class="op">.</span>event_source<span class="op">().</span>next_event<span class="op">();</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>event<span class="op">.</span>type <span class="op">==</span> WindowEventType<span class="op">::</span>WINDOW_FOCUS_GAINED<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Resume audio processing</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>            audio_graph_manager<span class="op">-&gt;</span>set_processing_enabled<span class="op">(</span><span class="kw">true</span><span class="op">);</span></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>            visual_renderer<span class="op">-&gt;</span>set_render_quality<span class="op">(</span>RenderQuality<span class="op">::</span>HIGH<span class="op">);</span></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>event<span class="op">.</span>type <span class="op">==</span> WindowEventType<span class="op">::</span>WINDOW_FOCUS_LOST<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Pause audio processing</span></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>            audio_graph_manager<span class="op">-&gt;</span>set_processing_enabled<span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>            visual_renderer<span class="op">-&gt;</span>set_render_quality<span class="op">(</span>RenderQuality<span class="op">::</span>LOW<span class="op">);</span></span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="eventsource-architecture">EventSource Architecture</h3>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> Vruta <span class="op">{</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> EventSource <span class="op">{</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>queue<span class="op">&lt;</span>WindowEvent<span class="op">&gt;</span> <span class="va">m_event_queue</span><span class="op">;</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>coroutine_handle<span class="op">&lt;&gt;&gt;</span> <span class="va">m_waiting_coroutines</span><span class="op">;</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Signal event from callback</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> signal<span class="op">(</span><span class="at">const</span> WindowEvent<span class="op">&amp;</span> event<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_event_queue</span><span class="op">.</span>push<span class="op">(</span>event<span class="op">);</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Resume all waiting coroutines</span></span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span><span class="op">&amp;</span> handle <span class="op">:</span> <span class="va">m_waiting_coroutines</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a>            handle<span class="op">.</span>resume<span class="op">();</span></span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">m_waiting_coroutines</span><span class="op">.</span>clear<span class="op">();</span></span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Awaitable for next event</span></span>
<span id="cb48-20"><a href="#cb48-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> next_event<span class="op">(</span><span class="bu">std::</span>optional<span class="op">&lt;</span>WindowEventType<span class="op">&gt;</span> filter <span class="op">=</span> <span class="bu">std::</span>nullopt<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-21"><a href="#cb48-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> EventAwaiter <span class="op">{</span></span>
<span id="cb48-22"><a href="#cb48-22" aria-hidden="true" tabindex="-1"></a>            EventSource<span class="op">&amp;</span> source<span class="op">;</span></span>
<span id="cb48-23"><a href="#cb48-23" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>optional<span class="op">&lt;</span>WindowEventType<span class="op">&gt;</span> filter<span class="op">;</span></span>
<span id="cb48-24"><a href="#cb48-24" aria-hidden="true" tabindex="-1"></a>            WindowEvent result<span class="op">;</span></span>
<span id="cb48-25"><a href="#cb48-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-26"><a href="#cb48-26" aria-hidden="true" tabindex="-1"></a>            <span class="dt">bool</span> await_ready<span class="op">()</span> <span class="op">{</span></span>
<span id="cb48-27"><a href="#cb48-27" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>source<span class="op">.</span><span class="va">m_event_queue</span><span class="op">.</span>empty<span class="op">())</span> <span class="op">{</span></span>
<span id="cb48-28"><a href="#cb48-28" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb48-29"><a href="#cb48-29" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb48-30"><a href="#cb48-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-31"><a href="#cb48-31" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Check if event matches filter</span></span>
<span id="cb48-32"><a href="#cb48-32" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>filter <span class="op">&amp;&amp;</span> source<span class="op">.</span><span class="va">m_event_queue</span><span class="op">.</span>front<span class="op">().</span>type <span class="op">!=</span> <span class="op">*</span>filter<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-33"><a href="#cb48-33" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb48-34"><a href="#cb48-34" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb48-35"><a href="#cb48-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-36"><a href="#cb48-36" aria-hidden="true" tabindex="-1"></a>                result <span class="op">=</span> source<span class="op">.</span><span class="va">m_event_queue</span><span class="op">.</span>front<span class="op">();</span></span>
<span id="cb48-37"><a href="#cb48-37" aria-hidden="true" tabindex="-1"></a>                source<span class="op">.</span><span class="va">m_event_queue</span><span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb48-38"><a href="#cb48-38" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb48-39"><a href="#cb48-39" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb48-40"><a href="#cb48-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-41"><a href="#cb48-41" aria-hidden="true" tabindex="-1"></a>            <span class="dt">void</span> await_suspend<span class="op">(</span><span class="bu">std::</span>coroutine_handle<span class="op">&lt;&gt;</span> handle<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-42"><a href="#cb48-42" aria-hidden="true" tabindex="-1"></a>                source<span class="op">.</span><span class="va">m_waiting_coroutines</span><span class="op">.</span>push_back<span class="op">(</span>handle<span class="op">);</span></span>
<span id="cb48-43"><a href="#cb48-43" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb48-44"><a href="#cb48-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-45"><a href="#cb48-45" aria-hidden="true" tabindex="-1"></a>            WindowEvent await_resume<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> result<span class="op">;</span> <span class="op">}</span></span>
<span id="cb48-46"><a href="#cb48-46" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb48-47"><a href="#cb48-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-48"><a href="#cb48-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> EventAwaiter<span class="op">{*</span><span class="kw">this</span><span class="op">,</span> filter<span class="op">};</span></span>
<span id="cb48-49"><a href="#cb48-49" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb48-50"><a href="#cb48-50" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb48-51"><a href="#cb48-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-52"><a href="#cb48-52" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This architecture transforms window management from <strong>callback
spaghetti</strong> into <strong>expressive temporal
coordination</strong>.</p>
<hr />
<h2 id="domain-composition-and-processing-tokens">Domain Composition and
Processing Tokens</h2>
<h3 id="the-token-system">The Token System</h3>
<p>MayaFlux uses <strong>bitfield-composed tokens</strong> to specify
processing characteristics:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Node processing tokens</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> Nodes <span class="op">{</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> <span class="kw">class</span> ProcessingToken <span class="op">{</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>        AUDIO_RATE<span class="op">,</span>    <span class="co">// Process at audio sample rate</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>        VISUAL_RATE<span class="op">,</span>   <span class="co">// Process at visual frame rate</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>        CUSTOM_RATE    <span class="co">// User-defined processing rate</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a><span class="co">// Buffer processing tokens (bitfield)</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> Buffers <span class="op">{</span></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> ProcessingToken <span class="op">:</span> <span class="dt">uint32_t</span> <span class="op">{</span></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Rate tokens</span></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a>        SAMPLE_RATE <span class="op">=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a>        FRAME_RATE <span class="op">=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Device tokens</span></span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a>        CPU_PROCESS <span class="op">=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="dv">8</span><span class="op">,</span></span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a>        GPU_PROCESS <span class="op">=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="dv">9</span><span class="op">,</span></span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-21"><a href="#cb49-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Concurrency tokens</span></span>
<span id="cb49-22"><a href="#cb49-22" aria-hidden="true" tabindex="-1"></a>        SEQUENTIAL <span class="op">=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="dv">16</span><span class="op">,</span></span>
<span id="cb49-23"><a href="#cb49-23" aria-hidden="true" tabindex="-1"></a>        PARALLEL <span class="op">=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="dv">17</span><span class="op">,</span></span>
<span id="cb49-24"><a href="#cb49-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-25"><a href="#cb49-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Backend combinations</span></span>
<span id="cb49-26"><a href="#cb49-26" aria-hidden="true" tabindex="-1"></a>        AUDIO_BACKEND <span class="op">=</span> SAMPLE_RATE <span class="op">|</span> CPU_PROCESS <span class="op">|</span> SEQUENTIAL<span class="op">,</span></span>
<span id="cb49-27"><a href="#cb49-27" aria-hidden="true" tabindex="-1"></a>        GRAPHICS_BACKEND <span class="op">=</span> FRAME_RATE <span class="op">|</span> GPU_PROCESS <span class="op">|</span> PARALLEL</span>
<span id="cb49-28"><a href="#cb49-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb49-29"><a href="#cb49-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb49-30"><a href="#cb49-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-31"><a href="#cb49-31" aria-hidden="true" tabindex="-1"></a><span class="co">// Coroutine processing tokens</span></span>
<span id="cb49-32"><a href="#cb49-32" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> Vruta <span class="op">{</span></span>
<span id="cb49-33"><a href="#cb49-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> <span class="kw">class</span> ProcessingToken <span class="op">{</span></span>
<span id="cb49-34"><a href="#cb49-34" aria-hidden="true" tabindex="-1"></a>        SAMPLE_ACCURATE<span class="op">,</span>  <span class="co">// Sample-level temporal precision</span></span>
<span id="cb49-35"><a href="#cb49-35" aria-hidden="true" tabindex="-1"></a>        FRAME_ACCURATE<span class="op">,</span>   <span class="co">// Frame-level temporal precision</span></span>
<span id="cb49-36"><a href="#cb49-36" aria-hidden="true" tabindex="-1"></a>        EVENT_DRIVEN<span class="op">,</span>     <span class="co">// Sporadic event processing</span></span>
<span id="cb49-37"><a href="#cb49-37" aria-hidden="true" tabindex="-1"></a>        CUSTOM</span>
<span id="cb49-38"><a href="#cb49-38" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb49-39"><a href="#cb49-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="domain-composition">Domain Composition</h3>
<p>Domains combine tokens into unified computational contexts:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="kw">class</span> Domain <span class="op">:</span> <span class="dt">uint64_t</span> <span class="op">{</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Audio processing with sample-accurate coordination</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>    AUDIO <span class="op">=</span> <span class="op">(</span>Nodes<span class="op">::</span>ProcessingToken<span class="op">::</span>AUDIO_RATE <span class="op">&lt;&lt;</span> <span class="dv">32</span><span class="op">)</span> <span class="op">|</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>            <span class="op">(</span>Buffers<span class="op">::</span>ProcessingToken<span class="op">::</span>AUDIO_BACKEND <span class="op">&lt;&lt;</span> <span class="dv">16</span><span class="op">)</span> <span class="op">|</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">(</span>Vruta<span class="op">::</span>ProcessingToken<span class="op">::</span>SAMPLE_ACCURATE<span class="op">),</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Graphics with frame-accurate synchronization</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>    GRAPHICS <span class="op">=</span> <span class="op">(</span>Nodes<span class="op">::</span>ProcessingToken<span class="op">::</span>VISUAL_RATE <span class="op">&lt;&lt;</span> <span class="dv">32</span><span class="op">)</span> <span class="op">|</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>               <span class="op">(</span>Buffers<span class="op">::</span>ProcessingToken<span class="op">::</span>GRAPHICS_BACKEND <span class="op">&lt;&lt;</span> <span class="dv">16</span><span class="op">)</span> <span class="op">|</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>               <span class="op">(</span>Vruta<span class="op">::</span>ProcessingToken<span class="op">::</span>FRAME_ACCURATE<span class="op">)</span></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="usage-pattern">Usage Pattern</h3>
<div class="sourceCode" id="cb51"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Create audio node</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> sine <span class="op">=</span> vega<span class="op">.</span>Sine<span class="op">(</span><span class="fl">440.0</span><span class="op">)</span> <span class="op">|</span> Domain<span class="op">::</span>Audio<span class="op">;</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Create graphics buffer</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> vertex_buffer <span class="op">=</span> vega<span class="op">.</span>VKBuffer<span class="op">(</span>vertices<span class="op">)</span> <span class="op">|</span> Domain<span class="op">::</span>Graphics<span class="op">;</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Custom domain composition for future extensions</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> custom_domain <span class="op">=</span> compose_domain<span class="op">(</span></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>    Nodes<span class="op">::</span>ProcessingToken<span class="op">::</span>CUSTOM_RATE<span class="op">,</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>    Buffers<span class="op">::</span>ProcessingToken<span class="op">::</span>GPU_PROCESS <span class="op">|</span> Buffers<span class="op">::</span>ProcessingToken<span class="op">::</span>PARALLEL<span class="op">,</span></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>    Vruta<span class="op">::</span>ProcessingToken<span class="op">::</span>CUSTOM</span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> quantum_node <span class="op">=</span> vega<span class="op">.</span>custom_processor<span class="op">()</span> <span class="op">|</span> custom_domain<span class="op">;</span></span></code></pre></div>
<p>The token system is <strong>extensible</strong>—new domains can be
composed from existing tokens or new tokens added for specialized
processing requirements (neural accelerators, quantum processors,
biomimetic hardware, etc.).</p>
<hr />
<h2 id="current-implementation-status">Current Implementation
Status</h2>
<h3 id="production-ready-systems">Production-Ready Systems ✓</h3>
<p><strong>Graphics Infrastructure</strong> - VulkanBackend with full
device/queue management (graphics, compute, transfer queues) - VKBuffer
with 6 usage types (staging, device, compute, vertex, index, uniform) -
Compute and graphics pipeline creation via VKComputePipeline and
VKGraphicsPipeline - Shader compilation with hot-reload support via
ShaderFoundry - Multi-stage shader support
(vertex/fragment/geometry/tessellation/compute) - Window integration and
swapchain management via DisplayService - RootGraphicsBuffer with
processing chain integration (parallel to RootAudioBuffer) - Portal
coordination layers: ShaderFoundry, ComputePress, RenderFlow - Full
upload/download buffer support for CPU ↔︎ GPU data transfer - Descriptor
management and push constants - Command buffer lifecycle management -
<strong>300+ graphics-specific tests validating
infrastructure</strong></p>
<p><strong>Audio Infrastructure</strong> - RtAudio integration with
multi-channel routing - Sample-accurate processing via RootNode and
RootAudioBuffer - Lock-free node registration and channel routing -
Generator nodes (sine, noise, impulse, polynomial) - Processing nodes
(IIR filters, gain, chain) - Fluent operators (<code>&gt;&gt;</code>,
<code>*</code>, <code>+</code>) - Backend abstraction (pluggable) -
<strong>180+ node tests, 100+ buffer tests</strong></p>
<p><strong>Lock-Free Coordination</strong> - RootNode atomic
registration and processing - NodeGraphManager concurrent coordination -
BufferManager atomic accumulation (audio and graphics) - Atomic state
guards with wait-free patterns - <strong>150+ tests validating lock-free
patterns</strong></p>
<p><strong>Coroutine Infrastructure</strong> - TaskScheduler with clock
coordination - SampleClock (passive, audio-driven) and FrameClock
(active, graphics-driven) - Vruta scheduling primitives (SampleDelay,
BufferDelay, FrameDelay) - Kriya creative patterns (metro, timer, event
chains, buffer pipelines) - EventSource integration for window events -
<strong>150+ tests validating temporal coordination</strong></p>
<p><strong>Windowing System</strong> - GLFW integration with EventSource
- Window event coroutines - Multi-window support - Input handling via
coroutine patterns - Graphics backend registration</p>
<p><strong>ComputationGrammar Foundation</strong> - Rule-based matching
system operational - UniversalMatcher combinators functional -
ExecutionContext infrastructure complete - Priority-based rule
evaluation tested - <strong>80+ tests for core
functionality</strong></p>
<p><strong>NDData Abstractions</strong> - DataVariant type system with
multiple primitive types - DataDimension descriptors for dimensional
metadata - Modality definitions (Audio, Spectral, Image, Video, Vertex,
Tensor) - Region-based access patterns operational - VKBuffer modality
integration functional - <strong>90+ tests</strong></p>
<h3 id="functional-but-limited">Functional But Limited ⚙</h3>
<p><strong>Graphics Nodes</strong> - Architecture designed but not yet
implemented - Current graphics processing is buffer-centric only -
Node-level visual processing planned for future expansion</p>
<p><strong>Cross-Modal Data Flow</strong> - Infrastructure exists
(unified buffer abstractions, domain tokens, coroutine coordination) -
VKBuffer integrates with NDData modality system - Actual production
workflows (audio → compute shader, spectral → visual modulation) remain
conceptual demonstrations - Architectural validation complete; creative
workflow validation pending</p>
<p><strong>Yantra Transformers</strong> - Architecture solid and proven
(UniversalTransformer hierarchy, declarative composition) - Grammar
integration functional - Mathematical operations: normalize, scale,
clamp operational - Temporal operations: reverse, basic time-stretch
operational - Spectral operations: basic FFT functional via FFTW
integration - Advanced algorithms (phase vocoder, granular synthesis,
adaptive filtering) in active development</p>
<p><strong>ComputationGrammar Stress Testing</strong> - Core
functionality operational and tested - Complex rule interactions tested
in isolation - Real-world pipeline validation with large grammars
limited - Production-scale stress testing pending</p>
<h3 id="active-development">Active Development →</h3>
<p><strong>Container-Graphics Integration</strong> -
NDimensionalContainers designed but not yet feeding GPU pipelines -
Compute shader transformers for NDData planned - Region-based GPU data
access architecture designed</p>
<p><strong>Audio-Visual Coordination Workflows</strong> - Spectral
analysis → shader parameter patterns conceptually designed -
Coroutine-based audio-visual synchronization infrastructure exists -
Concrete production examples in development</p>
<p><strong>Inter-Component Integration</strong> - Component-level tests:
~700 total - Cross-component stress testing: ~50% coverage - Real-world
creative validation: limited to proof-of-concept demonstrations -
Production stability: unknown, requires adversarial testing</p>
<h3 id="planned-expansions">Planned Expansions</h3>
<p><strong>Live Coding Integration (Lila)</strong> - LLVM 21-based JIT
compilation functional - Sub-buffer latency code execution demonstrated
- Full integration with all MayaFlux subsystems in progress - Live
modification of node graphs, buffer processors, and shaders</p>
<p><strong>Game Engine Plugins</strong> - UE5 C++ bindings architecture
designed - Godot C++ bindings architecture designed - Real-time
audio-visual coordination for interactive media</p>
<p><strong>Advanced Processing Backends</strong> - Neural accelerator
integration (TPU, NPU support) - Quantum-inspired algorithms - Custom
hardware acceleration via pluggable backend system</p>
<hr />
<h2 id="future-vision-and-research-questions">Future Vision and Research
Questions</h2>
<h3 id="beyond-traditional-dsp">Beyond Traditional DSP</h3>
<p>MayaFlux enables computational patterns impossible in analog-inspired
systems:</p>
<p><strong>Recursive Processing</strong></p>
<div class="sourceCode" id="cb52"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Recursive feedback that modifies its own structure</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> recursive_node <span class="op">=</span> vega<span class="op">.</span>custom<span class="op">([](</span><span class="dt">double</span> input<span class="op">,</span> NodeState<span class="op">&amp;</span> state<span class="op">)</span> <span class="op">{</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>state<span class="op">.</span>recursion_depth <span class="op">&lt;</span> <span class="dv">5</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> recursive_node<span class="op">-&gt;</span>process_sample<span class="op">()</span> <span class="op">*</span> <span class="fl">0.5</span> <span class="op">+</span> input<span class="op">;</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> input<span class="op">;</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a><span class="op">});</span></span></code></pre></div>
<p><strong>Grammar-Defined Adaptive Pipelines</strong></p>
<div class="sourceCode" id="cb53"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Pipeline adapts based on runtime data characteristics</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> adaptive <span class="op">=</span> ComputationPipeline<span class="op">(</span>grammar<span class="op">)</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>add_input<span class="op">(</span>unknown_data<span class="op">)</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>auto_select_operations<span class="op">()</span>  <span class="co">// Grammar determines optimal path</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>execute<span class="op">();</span></span></code></pre></div>
<p><strong>Ahead-of-Time Complex Transformations</strong></p>
<div class="sourceCode" id="cb54"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Pre-calculate expensive operations impossible in real-time</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> precomputed <span class="op">=</span> container<span class="op">-&gt;</span>transform_region<span class="op">(</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>    large_audio_region<span class="op">,</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">[](</span><span class="kw">auto</span> data<span class="op">)</span> <span class="op">{</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> apply_expensive_convolution<span class="op">(</span>data<span class="op">);</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Use precomputed results in real-time processing</span></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>realtime_node<span class="op">-&gt;</span>set_lookup_table<span class="op">(</span>precomputed<span class="op">);</span></span></code></pre></div>
<p><strong>True Cross-Modal Synthesis</strong></p>
<div class="sourceCode" id="cb55"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Visual parameters generate audio via compute shader</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> visual_to_audio <span class="op">=</span> <span class="op">[&amp;]()</span> <span class="op">{</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Sample pixel buffer via compute shader</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> pixel_data <span class="op">=</span> compute_shader_sample<span class="op">(</span>visual_buffer<span class="op">,</span> x<span class="op">,</span> y<span class="op">);</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Map visual features to audio parameters</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> frequency <span class="op">=</span> map_range<span class="op">(</span>pixel_data<span class="op">.</span>brightness<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">255</span><span class="op">,</span> <span class="dv">20</span><span class="op">,</span> <span class="dv">2000</span><span class="op">);</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> amplitude <span class="op">=</span> pixel_data<span class="op">.</span>saturation<span class="op">;</span></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> complex_buffer_tick<span class="op">(</span>frequency<span class="op">)</span> <span class="op">*</span> amplitude<span class="op">;</span></span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a><span class="co">// Audio parameters drive visual compute shaders</span></span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> audio_to_visual_compute <span class="op">=</span> <span class="op">[&amp;](</span><span class="at">const</span> SpectralData<span class="op">&amp;</span> spectrum<span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a>    ComputeShaderParams params<span class="op">;</span></span>
<span id="cb55-16"><a href="#cb55-16" aria-hidden="true" tabindex="-1"></a>    params<span class="op">.</span>bass_energy <span class="op">=</span> spectrum<span class="op">.</span>energy_in_range<span class="op">(</span><span class="dv">20</span><span class="op">,</span> <span class="dv">200</span><span class="op">);</span></span>
<span id="cb55-17"><a href="#cb55-17" aria-hidden="true" tabindex="-1"></a>    params<span class="op">.</span>mid_energy <span class="op">=</span> spectrum<span class="op">.</span>energy_in_range<span class="op">(</span><span class="dv">200</span><span class="op">,</span> <span class="dv">2000</span><span class="op">);</span></span>
<span id="cb55-18"><a href="#cb55-18" aria-hidden="true" tabindex="-1"></a>    params<span class="op">.</span>high_energy <span class="op">=</span> spectrum<span class="op">.</span>energy_in_range<span class="op">(</span><span class="dv">2000</span><span class="op">,</span> <span class="dv">20000</span><span class="op">);</span></span>
<span id="cb55-19"><a href="#cb55-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb55-20"><a href="#cb55-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Compute shader processes texture based on audio features</span></span>
<span id="cb55-21"><a href="#cb55-21" aria-hidden="true" tabindex="-1"></a>    compute_processor<span class="op">-&gt;</span>update_push_constants<span class="op">(&amp;</span>params<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>params<span class="op">));</span></span>
<span id="cb55-22"><a href="#cb55-22" aria-hidden="true" tabindex="-1"></a>    compute_processor<span class="op">-&gt;</span>dispatch_workgroups<span class="op">(</span>texture_width <span class="op">/</span> <span class="dv">16</span><span class="op">,</span> texture_height <span class="op">/</span> <span class="dv">16</span><span class="op">);</span></span>
<span id="cb55-23"><a href="#cb55-23" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="research-questions">Research Questions</h3>
<p>MayaFlux is presented as an <strong>architectural experiment</strong>
seeking community validation:</p>
<ol type="1">
<li><strong>Does C++20/23 enable genuinely unified multimedia
processing?</strong>
<ul>
<li>Are coroutines sufficient for complex temporal coordination across
audio and graphics?</li>
<li>Can lock-free patterns scale to large-scale creative systems with
thousands of nodes/buffers?</li>
</ul></li>
<li><strong>Is grammar-based computation viable for real-time creative
work?</strong>
<ul>
<li>Performance implications of rule matching in critical paths?</li>
<li>Expressive power vs. computational overhead trade-offs?</li>
</ul></li>
<li><strong>Can cross-modal abstractions remain performant?</strong>
<ul>
<li>NDData overhead in tight audio/graphics loops?</li>
<li>Cache coherency with dimensional abstractions?</li>
<li>GPU upload/download patterns with semantic metadata?</li>
</ul></li>
<li><strong>What creative workflows emerge from digital-first
thinking?</strong>
<ul>
<li>What patterns become possible that weren’t before?</li>
<li>What analog metaphors actually serve creativity vs. constrain
it?</li>
<li>How do composers/visual artists approach unified data
transformation?</li>
</ul></li>
<li><strong>Does the Portal coordination layer scale?</strong>
<ul>
<li>ShaderFoundry/ComputePress/RenderFlow overhead in complex
scenes?</li>
<li>Can declarative graphics coordination match performance of manual
Vulkan?</li>
</ul></li>
</ol>
<hr />
<h2 id="seeking-adversarial-testing-and-community-validation">Seeking:
Adversarial Testing and Community Validation</h2>
<p>This project needs:</p>
<ul>
<li><strong>Alpha testers</strong> willing to break things and
stress-test edge cases</li>
<li><strong>Code review</strong> from experienced C++ developers
(especially graphics/audio specialists)</li>
<li><strong>Creative validation</strong> from composers, visual artists,
researchers working at the intersection of domains</li>
<li><strong>Use cases</strong> I haven’t imagined—what would YOU build
with unified audio-visual processing?</li>
<li><strong>Architectural critique</strong>—what scales, what doesn’t?
Where are the bottlenecks?</li>
<li><strong>Cross-platform testing</strong>—currently developed on
Linux/Vulkan; Windows/macOS validation needed</li>
</ul>
<p>MayaFlux is <strong>not presented as a finished tool</strong>, but as
a <strong>paradigm proposal</strong> seeking validation or refutation
through community scrutiny.</p>
<p>The core systems work. The tests pass. Graphics infrastructure is
production-ready. Audio processing is stable. But 8 months of solo
development cannot validate real-world usage patterns, edge cases,
creative applicability, or whether the unification of audio and graphics
actually serves creative workflows or introduces unnecessary
complexity.</p>
<p><strong>This is an honest call for collaboration</strong>—to either
prove this paradigm has merit or expose its fundamental limitations
through adversarial testing and creative exploration.</p>
<hr />
<h2 id="contact-resources">Contact &amp; Resources</h2>
<p><strong>ADC25 Virtual Presentation</strong></p>
<ul>
<li>30-minute discussion slots available</li>
<li>Live demos: real-time code modification (Lila JIT), audio-visual
coordination, grammar-based pipelines</li>
<li>GitHub repository (available upon request during development)</li>
<li>Comprehensive documentation and architectural diagrams</li>
</ul>
<p><strong>Project Status</strong></p>
<ul>
<li>~100,000+ lines of C++ (including full Vulkan backend, audio
infrastructure, coroutine system)</li>
<li>700+ component tests across all subsystems</li>
<li>8 months solo development (March 2025 - November 2025)</li>
<li>Early-stage architectural research seeking validation</li>
</ul>
<p><strong>Seeking</strong></p>
<ul>
<li>Adversarial testing collaborators to stress-test at scale</li>
<li>Code review from audio/graphics/systems developers</li>
<li>Creative use case validation from composers and visual artists</li>
<li>Research partnerships for exploring digital-first creative
paradigms</li>
<li>Industry feedback on production viability</li>
</ul>
<p><strong>Technical Contact</strong></p>
<ul>
<li>GitHub: <a href="https://github.com/MayaFlux/MayaFlux">MayaFlux/MayaFlux</a>
(private during development)</li>
<li>GitLab: <a href="https://gitlab.com/MayaFlux/MayaFlux">MayaFlux/MayaFlux</a>
(private during development, primary docs host)</li>
<li>Email: <a href="mayafluxcollective@proton.me">Proton mail</a></li>
<li>Early Access: <a href="https://forms.gle/W2VbnpDj59QN4GYd8">Form</a></li>
<li>Discussion: Open to collaborations, partnerships, and critical
feedback</li>
</ul>
<hr />
<h2 id="conclusion">Conclusion</h2>
<p>MayaFlux represents not just a new framework, but a fundamental
rethinking of creative computation—moving from analog simulation to true
digital-first paradigms where data transformation becomes the primary
creative medium.</p>
<p><strong>Audio and graphics are no longer separate domains</strong>,
but different modalities of the same unified computational substrate.
Sample-accurate audio coordination and frame-accurate graphics
coordination use the same coroutine infrastructure. AudioBuffer and
VKBuffer integrate with the same processing chains. Mathematical
transformations, temporal manipulations, and spectral operations apply
equally to sound samples and pixel arrays.</p>
<p>The architecture is <strong>proven at the component level</strong>.
Lock-free patterns work. Coroutines coordinate complex temporal
relationships. Grammar-based pipelines enable declarative operation
selection. Vulkan backend provides full GPU processing capabilities.
NDData unifies cross-modal data access.</p>
<p>What remains is <strong>validation at scale</strong>—in production
systems, under creative constraints, with real-world workloads. This
document presents the architecture honestly: what’s complete, what’s
functional but limited, what’s planned.</p>
<p>The paradigm shift is real. Whether it’s <strong>useful</strong>
requires community engagement.</p>
<hr />
<p><em>MayaFlux: Where audio samples and pixel arrays are just different
views of the same computational material, where time itself becomes
malleable through coroutines, and where mathematical relationships
replace analog metaphors as the language of creative
expression.</em></p>
<p><strong>Licensed under GPL-3.0 | Copyright © 2025 Ranjith Hegde /
MayaFlux Project</strong></p>
</body>
</html>
